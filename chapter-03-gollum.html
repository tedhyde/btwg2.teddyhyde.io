---
layout: default
title: GitHub Wikis with Gollum
---

<div id="excerpt"><div class="sect1">
    <h2>GitHub Wikis with Gollum</h2>
    <div class="sectionbody"><div class="paragraph"><p>
	  Wikis have revolutionized the way we create and digest
	  information. It turns out they are a great complement to technical
	  projects (code repositories) because they allow non-technical
	  users to contribute in ways other than adding code. Gollum
	  is an open source wiki created by GitHub. Just as Git has
	  revolutionized collaborative editing of code, Gollum wikis layer the
	  benefits of Git onto the widely used Wiki publishing workflow. Gollum
	  wikis are themselves repositories that generally annotate other
	  typically code-centric repositories. GitHub makes it easy to associate
	  a wiki with any
	  repository.
    </p></div></div>
</div></div>
<div id="header">
</div>
<div id="content" style="display: none">
  <div class="sect1">
    <h2 id="_github_wikis_with_gollum">GitHub Wikis with Gollum</h2>
    <div class="sectionbody">
      <div class="paragraph">
	<p>Wikis have revolutionized the way we create and digest
	  information. It turns out they are a great complement to technical
	  projects (code repositories) because they allow non-technical
	  users to contribute in ways other than adding code. Gollum
	  is an open source wiki created by GitHub. Just as Git has
	  revolutionized collaborative editing of code, Gollum wikis layer the
	  benefits of Git onto the widely used Wiki publishing workflow. Gollum
	  wikis are themselves repositories that generally annotate other
	  typically code-centric repositories. GitHub makes it easy to associate
	  a wiki with any
	  repository.</p>
      </div>
      <div class="paragraph">
	<p>In this chapter we’ll explore the basics of using Gollum, creating a
	  wiki on GitHub and then understanding how to edit it on GitHub, and as
	  a repository on our local machine. We will then create a Gollum wiki by
	  hand from the command line, and show the bare minimum set of files to
	  call something a Gollum repository. Finally, we will build a simple
	  image organization tool which allows us to edit a Gollum wiki in an
	  entirely different way, but still publishes information into GitHub as
	  a regular Gollum wiki, exploring a little bit of the internals of Git
	  along the way.</p>
      </div>
      <div class="admonitionblock note">
	<table>
	  <tr>
	    <td class="icon">
	      <div class="title">Note</div>
	    </td>
	    <td class="content">
	      This chapter demonstrates code which modifies a Git repository
	      programmatically. You will be able to follow along without possessing
	      a deep understanding of the internals of Git. And, a good supplement
	      to this chapter (and later chapters as well) is the
	      <a href="http://shop.oreilly.com/product/0636920022862.do">"Version Control
		with Git"</a> book from O’Reilly.
	    </td>
	  </tr>
	</table>
      </div>
      <div class="sect2">
	<h3 id="__the_story_of_smeagol">"The Story of Smeagol…​"</h3>
	<div class="paragraph">
	  <p>At its most basic form, a Gollum wiki is a Git repository with a single file,
	    <code>Home.ext</code> (<code>ext</code> would be any of the supported wiki markup formats,
	    which we will talk about later).</p>
	</div>
	<div class="sect3">
	  <h4 id="_repository_linked_wikis">Repository Linked Wikis</h4>
	  <div class="paragraph">
	    <p>Any repository on GitHub, public or private, can have an associated Gollum wiki.
	      To create a wiki linked to your repository, visit the repository
	      page and then look in the rightmost colum. You’ll see an icon that
	      looks like a book, next to which will be the word "Wiki," as in <a href="#integrated_gollum_wiki_in_the_sidebar">Accessing the associated wiki from the sidebar</a>.</p>
	  </div>
	  <div id="integrated_gollum_wiki_in_the_sidebar" class="imageblock">
	    <div class="content">
	      <img src="images/btwg_03in01.png" alt="btwg 03in01">
	    </div>
	    <div class="title">Figure 1. Accessing the associated wiki from the sidebar</div>
	  </div>
	  <div class="paragraph">
	    <p>Clicking this link will bring you to a page where you are asked to
	      create a wiki for the first time. GitHub will ask you to create the
	      "Home" page, which is the starting point in a Gollum wiki (<a href="#starting_a_gollum_wiki">Genesis of a new wiki, creating the home page</a>). GitHub will
	      automatically create a page template with the project name; you can
	      customize this information to suit your own needs. Clicking "Save Page" will save your first page and create the wiki for you.</p>
	  </div>
	  <div id="starting_a_gollum_wiki" class="imageblock">
	    <div class="content">
	      <img src="images/btwg_03in02.png" alt="btwg 03in02">
	    </div>
	    <div class="title">Figure 2. Genesis of a new wiki, creating the home page</div>
	  </div>
	  <div class="paragraph">
	    <p>Your wiki is now as public as your repository is public. Public
	      repositories have public wikis, accessible to anyone. Private
	      repositories have private wikis, accessible only to those users or
	      organizations which have rights to edit the repository data.</p>
	  </div>
	  <div class="paragraph">
	    <p>Let’s review the markup options for Gollum wikis now.</p>
	  </div>
	</div>
	<div class="sect3">
	  <h4 id="_markup_and_structure">Markup and Structure</h4>
	  <div class="paragraph">
	    <p>Gollum files can be written in any of the supported "Github Markup" formats, which
	      includes ASCIIdoc, Creole, Markdown, Org Mode, Pod, RDoc,
	      ReStructuredText, Textile, and MediaWiki. The variety of markup
	      languages brings flexibility but it can be confusing to know which one
	      to use. Markdown (and its variant cousins) is the most popular markup
	      language on GitHub, and is well liked on other popular sites like
	      Stack Overflow. If you are unsure which language to use, Markdown is a
	      safe bet because it is ubiquitous across GitHub. The <a href="#Jekyll">[Jekyll]</a>
	      chapter has a much deeper overview of Markdown.</p>
	  </div>
	  <div class="paragraph">
	    <p>If you do choose Markdown, In addition to the standard vanilla
	      Markdown language tags, Gollum adds its own set wiki specific tags. There
	      are often subtle (or conflicting) differences from other Wiki markup
	      so it is worth reviewing the
	      <a href="https://github.com/gollum/gollum/wiki">Gollum repository documentation
		page</a>. We’ll go over the most important ones here.</p>
	  </div>
	  <div class="sect4">
	    <h5 id="_links">Links</h5>
	    <div class="paragraph">
	      <p>Links obviously convert into the <code>&lt;a&gt;</code> HTML tag. Each format has its
		own linking format: in Markdown you use <code>[text](URL)</code>. Gollum adds its
		own link tag: <code><a id="Link"></a></code>.</p>
	    </div>
	    <div class="paragraph">
	      <p>In addition:</p>
	    </div>
	    <div class="ulist">
	      <ul>
		<li>
		  <p>You can add a link title using the bar character:
		    <code>[[<a href="http://foobar.com%7CA" class="bare">http://foobar.com|A</a> link to foobar]]</code>.</p>
		</li>
		<li>
		  <p>Links can be either external or internal links.</p>
		</li>
		<li>
		  <p>A link like <code>[[Review Images]]</code> will be converted to a relative link
		    to the page <code>review-images.ext</code> (where ext is the preferred
		    extension you are using with your wiki, most likely Markdown).</p>
		</li>
	      </ul>
	    </div>
	    <div class="paragraph">
	      <p>Wikis are generally a collection of pages
		linked together in myriad ways, and this assumption about the
		structure of links makes writing pages easier.</p>
	    </div>
	    <div class="admonitionblock warning">
	      <table>
		<tr>
		  <td class="icon">
		    <div class="title">Warning</div>
		  </td>
		  <td class="content">
		    As we mentioned, there are differences between Gollum wiki tags and other wikis despite
		    having similar syntax. One such example is MediaWiki, where links with
		    titles use the opposite ordering <code>[[A link to
		      foobar|http://foobar.com]]</code>, so caveat emptor.
		  </td>
		</tr>
	      </table>
	    </div>
	  </div>
	  <div class="sect4">
	    <h5 id="_code_snippets">Code Snippets</h5>
	    <div class="paragraph">
	      <p>Gollum (the wiki) was invented at GitHub, a company dedicated to
		improving the lives of software developers, so it stands to reason
		Gollum wikis would support insertion of code snippets. To include a snippet of
		code, use three backticks, followed by an optional language name, and close
		the block of code using three more backticks. If you use the language
		name, Gollum will do proper syntax highlighting for most languages.</p>
	    </div>
	    <div class="listingblock">
	      <div class="content">
		<pre class="highlight"><code class="language-ruby" data-lang="ruby">```ruby
		    def hello
		    puts "hello"
		    end
		    ```</code></pre>
	      </div>
	    </div>
	    <div class="paragraph">
	      <p>Gollum
		<a href="https://github.com/gollum/gollum/wiki/Home/b16ce34e46e26600dc77bdf9b5aa6efcaf42026d#github-syntax-highlighting">at
		  one point</a> supported inclusion of files from any GitHub repository
		(and any branch!) using a syntax like this:</p>
	    </div>
	    <div class="listingblock">
	      <div class="content">
		<pre class="highlight"><code class="language-ruby" data-lang="ruby">```ruby:github:xrd/TeddyHyde/blob/master/Gemfile```</code></pre>
	      </div>
	    </div>
	    <div class="paragraph">
	      <p>Unforunately, this no longer works. According to current documentation
		on for Gollum, this tag allows inclusion of files from the parent
		repository:</p>
	    </div>
	    <div class="listingblock">
	      <div class="content">
		<pre class="highlight"><code class="language-ruby" data-lang="ruby">```ruby:/lib/gollum/app.rb```</code></pre>
	      </div>
	    </div>
	    <div class="paragraph">
	      <p>But, I found this to be broken as well. At the time of this writing,
		it tragically appears there is no way to insert code from the parent
		repository (or any other repository) into your Wiki content.</p>
	    </div>
	  </div>
	  <div class="sect4">
	    <h5 id="_structural_components">Structural Components</h5>
	    <div class="paragraph">
	      <p>Gollum includes capabilities to add sidebars, headers, and footers. If
		you include a file called <code>_Sidebar.ext</code> inside your repository,
		you’ll see it as a sidebar for every file rendered. Sidebars are
		automatically added to any file and any file from subdirectories that
		do not have their own sidebar files. If you wanted to add sidebars
		specific to a subdirectory, add another sidebar file in the
		subdirectory and this file will override the top level sidebar file.</p>
	    </div>
	  </div>
	  <div class="sect4">
	    <h5 id="_no_styling_or_javascript">No Styling or JavaScript</h5>
	    <div class="paragraph">
	      <p>For security reasons, Gollum strips out all CSS and
		JavaScript from raw markup files. You can include your own JavaScript
		or CSS file when running Gollum from the command line,
		(discussed momentarilys) using the <code>--custom-css</code> or
		<code>--custom-js</code> switches, but there is no way to include these files on a
		Wiki when your Gollum wiki is hosted on GitHub.</p>
	    </div>
	  </div>
	  <div class="sect4">
	    <h5 id="_inserting_images">Inserting Images</h5>
	    <div class="paragraph">
	      <p>Images are inserted into your document using the same tag format
		<code><a id="ceo.png"></a></code>: this adds the correct HTML tags to include an image
		named ceo.png inside your page. This basic syntax is often extended
		for additional funtionality. For example, to add a frame
		and an alt tag, you could use syntax like <code>[[ceo.png|frame|alt=Our CEO
		  relaxing on the beach]]</code>. This creates the proper HTML tags for the
		same image, and also adds a frame and alt text (helpful for better
		context and the extra information is used by screenreaders for
		visually impaired users as well).  Review the documentation on the
		Gollum repository for more details about the breadth of the image
		options.</p>
	    </div>
	    <div class="paragraph">
	      <p>You can also add images using the editor on GitHub. But you’ll notice
		that either way you are adding a link to an image and that there is no
		way to upload images into GitHub from the editor (<a href="#no_image_upload_only_image_urls">No image upload, only image URLs</a>).</p>
	    </div>
	    <div id="no_image_upload_only_image_urls" class="imageblock">
	      <div class="content">
		<img src="images/btwg_03in03.png" alt="btwg 03in03">
	      </div>
	      <div class="title">Figure 3. No image upload, only image URLs</div>
	    </div>
	    <div class="paragraph">
	      <p>For non-technical users, this makes Gollum Wikis on GitHub almost
		unusable if they need to add images. Let’s address this problem by
		building our own customized image-centric Gollum editor that still
		interoperates with regular Gollum Wikis. We can put this editor in
		front of non-technical users allowing them to add images, and then
		publish the wiki into GitHub as-is.</p>
	    </div>
	  </div>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_hacking_gollum">Hacking Gollum</h3>
	<div class="paragraph">
	  <p>Would an image editor based on Gollum be of general use? On many
	    software teams there is a tension between the design
	    team and the software team stemming from the fact that designers
	    generally don’t like using source code tools to manage images. This
	    causes issues when software developers rely on designs that are
	    rapidly changing: coders quickly get out of sync with the latest
	    designs. As a wiki, Gollum is the perfect tool to bridge this gap
	    between designers and coders: wikis are easy to read and modify by
	    non-technical users. Since Gollum is a hackable Wiki, we can build our
	    own workflow tool that allows designers to manage images and coders to
	    easily see those changes in a source code repository.</p>
	</div>
	<div class="paragraph">
	  <p>This will be a dual purpose repository. We can use the repository with
	    gollum as a standard wiki. And, we can use it with our application to
	    enter data in a more powerful way than gollum permits from its default
	    interface. The data will still be compatible with gollum and will be
	    hosted on GitHub.</p>
	</div>
	<div class="paragraph">
	  <p>To begin, install the Gollum ruby gem and then initialize our repository.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ gem install gollum
		$ mkdir images
		$ cd images
		$ git init .
		$ printf "### Our home" &gt; Home.md
		$ git add Home.md
		$ git commit -m "Initial commit"</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>We’ve just created a wiki compatible with Gollum. Let’s see what it
	    looks like inside Gollum. Run the <code>gollum</code> command then open
	    <em><a href="http://localhost:4567/" class="bare">http://localhost:4567/</a></em> in your browser, as shown in <a href="#gollum_running_locally">Viewing the wiki home page running on our laptop</a>.</p>
	</div>
	<div id="gollum_running_locally" class="imageblock">
	  <div class="content">
	    <img src="images/btwg_03in04.png" alt="btwg 03in04">
	  </div>
	  <div class="title">Figure 4. Viewing the wiki home page running on our laptop</div>
	</div>
	<div class="paragraph">
	  <p>As you can see, this tiny set of commands was enough to create the
	    basics of the gollum wiki structure.</p>
	</div>
	<div class="admonitionblock warning">
	  <table>
	    <tr>
	      <td class="icon">
		<div class="title">Warning</div>
	      </td>
	      <td class="content">
		If you edit a Gollum wiki from the command line, be aware that Gollum
		only looks inside the repository data for files. If you have added
		something to the working directory or have not yet commited files in
		your index, they will not be visible to Gollum.
	      </td>
	    </tr>
	  </table>
	</div>
	<div class="paragraph">
	  <p>Now let’s begin creating the web app that will help us store images
	    inside a Gollum wiki.</p>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_the_starting_point_of_a_gollum_editor">The Starting Point of a Gollum Editor</h3>
	<div class="paragraph">
	  <p>Now we will create our custom editor. We’ll use Sinatra, a Ruby
	    library that provides a simple DSL (domain specific language) for
	    building web applications. First, create a file called <code>image.rb</code> and
	    put the following contents inside it.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-ruby" data-lang="ruby">require 'sinatra'
		require 'gollum-lib'
		wiki = Gollum::Wiki.new(".")
		get '/pages' do
		"All pages: \n" + wiki.pages.collect { |p| p.path }.join( "\n" )
		end</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Then, create the Gemfile, install the dependencies and run the web
	    application.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ echo "source 'https://rubygems.org'
		gem 'sinatra', '1.4.5'
		gem 'gollum-lib', '4.1.0'" &gt;&gt; Gemfile
		$ bundle install
		Fetching gem metadata from https://rubygems.org/..........
		Resolving dependencies...
		Installing charlock_holmes (0.7.3)
		Using diff-lcs (1.2.5)
		Installing github-markup (1.3.3)
		Using mime-types (1.25.1)
		...
		$ bundle exec ruby image.rb
		$ open http://localhost:4567/pages</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>We specify at least the minimum 4.1.0 for <code>gollum-lib</code> as the interface
	    and list of supporting libraries has changed. We then run within the
	    bundler context (using gems installed from this Gemfile rather than
	    system gems) using the <code>bundle exec ruby image.rb</code> command.</p>
	</div>
	<div class="paragraph">
	  <p>You’ll see a report of the files that exist in our Gollum wiki right
	    now. We’ve only added one file, the <code>Home.md</code> file.</p>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_programmatically_handling_images">Programmatically Handling Images</h3>
	<div class="paragraph">
	  <p>Let’s add to our server. We want to support uploading ZIP files into
	    our system that we will then unpack and add to our repository, as well
	    as adding a list of these files to our wiki. Modify our <code>image.rb</code>
	    script to look like this:</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-ruby" data-lang="ruby">require 'sinatra'
		require 'gollum-lib'
		require 'tempfile'
		require 'zip'
		require 'rugged'

		def index( message=nil )
		response = File.read(File.join('.', 'index.html'))
		response.gsub!( "&lt;!-- message --&gt;\n", "&lt;h2&gt;Received and unpacked #{message}&lt;/h2&gt;" ) if message
		response
		end

		wiki = Gollum::Wiki.new(".")
		get '/' do
		index()
		end

		post '/unpack' do
		@repo = Rugged::Repository.new('.')
		@index = Rugged::Index.new

		zip = params[:zip][:tempfile]
		Zip::Zip.open( zip ) { |zipfile|
		zipfile.each do |f|
		contents = zipfile.read( f.name )
		filename = f.name.split( File::SEPARATOR ).pop
		if contents and filename and filename =~ /(png|jp?g|gif)$/i
		puts "Writing out: #{filename}"
		end
		end
		}
		index( params[:zip][:filename] )
		end</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>We’ll need an <code>index.html</code> file as well, so add that.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-ruby" data-lang="ruby">&lt;html&gt;
		&lt;body&gt;
		&lt;!-- message --&gt;
		&lt;form method='POST' enctype='multipart/form-data' action='/unpack'&gt;
		Choose a zip file:
		&lt;input type='file' name='zip'/&gt;
		&lt;input type='submit' name='submit'&gt;
		&lt;/form&gt;
		&lt;/body&gt;
		&lt;/html&gt;</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>This server script receives a POST request at the <code>/unpack</code> mount point and
	    retrieves a ZIP file from the parameters passed into the script. It
	    then opens the ZIP file (stored as a temp file on the server side),
	    iterates over each file in the ZIP, strips the full path from the
	    filename, and then prints out that filename (if it looks like an image)
	    to our console. Regardless of whether we are accessing the
	    root of our server, or have just posted to the <code>/unpack</code> mount point,
	    we always need to render our index page. When we do render it after
	    unzipping, we replace a comment stored in the index file with a status
	    message indicating the script received the correct file we posted.</p>
	</div>
	<div class="paragraph">
	  <p>We need to add the new Ruby libraries (RubyZip and Rugged) to our Gemfile:
	    update the required gems using the following commands, and then re-run
	    our Sinatra server script.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ echo "gem 'rubyzip', '1.1.7'
		gem 'rugged', '0.23.2'" &gt;&gt; Gemfile
		$ bundle install
		$ bundle exec ruby image.rb</code></pre>
	  </div>
	</div>
	<div class="admonitionblock warning">
	  <table>
	    <tr>
	      <td class="icon">
		<div class="title">Warning</div>
	      </td>
	      <td class="content">
		Rugged requires the libgit2 libraries (the pure C libraries for accessing
		Git repositories). Rugged gives you access to modification of Git
		repositories in the elegance of the Ruby language but with the speed
		of C. However, as this library is based on libgit2, and libgit2
		requires a C compiler, you will need to install this toolset first to
		install Rugged. On OSX this can look like <code>brew install cmake</code> or
		<code>apt-get install cmake</code> for Linux.
	      </td>
	    </tr>
	  </table>
	</div>
	<div class="paragraph">
	  <p>Then, we can open <code><a href="http://localhost:4567/" class="bare">http://localhost:4567/</a></code> and test uploading a zip file
	    full of images. You’ll see output similar to this in your console
	    after uploading a zip file.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">...
		[2014-05-07 10:08:49] INFO  WEBrick 1.3.1
		[2014-05-07 10:08:49] INFO  ruby 2.0.0 (2013-05-14)
		[x86_64-darwin13.0.0]
		== Sinatra/1.4.5 has taken the stage on 4567 for development with
		backup from WEBrick
		[2014-05-07 10:08:49] INFO  WEBrick::HTTPServer#start: pid=46370
		port=4567
		Writing out: IMG1234.png
		Writing out: IMG5678.png
		Writing out: IMG5678.png
		...</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>We are not doing anything beyond printing out the names of the images
	    in the zip. We’ll actually insert them into our Git repository in the
	    next section.</p>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_using_the_rugged_library">Using the Rugged Library</h3>
	<div class="paragraph">
	  <p>Our end goal for this script is to add files to our Gollum wiki, which
	    means adding files to the repository which backs our Gollum wiki.
	    The Rugged library handles the grunt work of this type of task easily.
	    Rugged is the successor to the original Ruby library for Git (called
	    Grit). Gollum, at the time of this writing uses the Grit libraries,
	    which also provide a binding to the libgit2 library, a "portable, pure
	    C implementation of the Git core methods." Grit has been abandoned
	    (though there are unofficial maintainers) and the Gollum team intends
	    to use Rugged as the long term library backing Gollum. Rugged is
	    written in Ruby and (provided you like Ruby) is a more
	    elegant way to interface with a Git repository than raw git
	    commands. As you might expect, Rugged is maintained by several employees of GitHub.</p>
	</div>
	<div class="paragraph">
	  <p>To change our script to modify our Git repository, let’s change our
	    script to no longer print the filename (using the <code>puts</code> method inside
	    the zip decode block) and instead call a new method called
	    <code>write_file_to_repo</code>. And, at the end of the zip block, add a method
	    called <code>build_commit</code> which builds the commit from our new files. Our
	    new file (omitting the unchanged code at the head of the file) looks
	    like this.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-ruby" data-lang="ruby">post '/unpack' do
		@repo = Rugged::Repository.new('.')
		@index = Rugged::Index.new

		zip = params[:zip][:tempfile]
		Zip::Zip.open( zip ) { |zipfile|
		zipfile.each do |f|
		contents = zipfile.read( f.name )
		filename = f.name.split( File::SEPARATOR ).pop
		if contents and filename and filename =~ /(png|jp?g|gif)$/i
		write_file_to_repo contents, filename # Write the file
		end
		end
		build_commit() # Build a commit from the new files
		}
		index( params[:zip][:filename] )
		end

		def get_credentials
		contents = File.read File.join( ENV['HOME'], ".gitconfig" )
		@email = $1 if contents =~ /email = (.+)$/
		@name = $1 if contents =~ /name = (.+)$/
		end

		def build_commit
		get_credentials()
		options = {}
		options[:tree] = @index.write_tree(@repo)
		options[:author] = { :email =&gt; @email, :name =&gt; @name, :time =&gt; Time.now }
		options[:committer] = { :email =&gt; @email, :name =&gt; @name, :time =&gt; Time.now }
		options[:message] ||= "Adding new images"
		options[:parents] = @repo.empty? ? [] : [ @repo.head.target ].compact
		options[:update_ref] = 'HEAD'

		Rugged::Commit.create(@repo, options)

		end

		def write_file_to_repo( contents, filename )
		oid = @repo.write( contents, :blob )
		@index.add(:path =&gt; filename, :oid =&gt; oid, :mode =&gt; 0100644)
		end</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>As you can see from the code above, Rugged handles a lot of the grunt
	    work required when creating a commit inside a Git repository. Rugged has a
	    simple interface to creating a blob inside your Git repository
	    (<code>write</code>), adding files to the index (the <code>add</code> method), and
	    then has a simple and clean interface to build the tree object
	    (<code>write_tree</code>) and then build the commit (<code>Rugged::Commit.create</code>).</p>
	</div>
	<div class="paragraph">
	  <p>To ease the burden of hard coding our commit credentials, we implement
	    a method called <code>get_credentials</code> that loads up your credentials from
	    a file located in your home directory called <code>.gitconfig</code>. You
	    probably have this if you have used Git for anything at all on your machine, but if this
	    file is missing, this method will fail. On my machine this file looks
	    like the following code snippet. The <code>get_credentials</code> method simply loads up this
	    file and parses it for the name and email address. If you wanted to
	    load the credentials using another method, or even hard code them, you
	    can just modify this method to suit your needs. The instance variables
	    <code>@email</code> and <code>@name</code> are then used in the <code>build_commit()</code> method.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-ini" data-lang="ini">[user]
		name = Chris Dawson
		email = xrdawson@gmail.com
		[credential]
		helper = cache --timeout=3600
		...</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Just to double check that everything worked properly, let’s verify
	    that things are working correctly after uploading a ZIP file. Jumping
	    into a terminal window after uploading a new file, imagine running
	    these commands:</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ git status</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>To our surprise, we will see something like this:</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ git status
		On branch master
		Changes to be committed:
		(use "git reset HEAD &lt;file&gt;..." to unstage)

		deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20120825_164703.jpg
		deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20130704_151522.jpg
		deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20130704_174217.jpg</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>We just added those files; why is Git reporting them as deleted?</p>
	</div>
	<div class="paragraph">
	  <p>To understand why this happens, remember that in Git there are three
	    places where files can reside: the working directory, the staging
	    area or index, and the repository itself. Your working directory is
	    the set of local files which you are working on. The <code>git status</code>
	    command describes itself as "show the working tree status." Rugged
	    operates on the repository itself, and our Rugged calls above operated
	    on the index and then built a commit. This is important to note
	    because our files will not exist in our working directory if we only
	    write them using the Rugged calls, and if we do this, we cannot
	    reference them inside our wiki page when we are running Gollum
	    locally. We’ll fix this in the next section.</p>
	</div>
	<div class="paragraph">
	  <p>We’ve now added the files to our repository, but we have not exposed
	    these files inside our wiki. Let’s modify our server script to write
	    out each file to a wiki page for review. As we mentioned in the
	    previous section, we need to make sure that we write the files to both
	    the working index and the repository (using the Rugged library <code>write</code>
	    call). Then we can generate a Review file which details all the images
	    uploaded.</p>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_optimizing_for_image_storage">Optimizing for Image Storage</h3>
	<div class="paragraph">
	  <p>If a designer uploads the same image twice, what happens? Our code
	    writes the uploaded image to a path on disk that is based on
	    the parent SHA hash of the repository (and this means we will always
	    write the file to a different path, even when the file is the same as
	    a previous uploaded file). It would look, to
	    an untrained eye, that we are adding the file file multiple times.
	    However, the nature of Git permits us to add the same file
	    multiple times without incurring any additional storage cost beyond
	    the first addition (and the minimal cost of a tree structure). When a file is added to git repository, an SHA hash
	    is generated from the file contents. For example, generating the SHA hash
	    from an empty file will always return the same SHA hash <span class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</span></p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ echo -en "blob 0\0" | shasum
		e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
		$ printf '' | git hash-object -w --stdin
		e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Adding a zip file with a bunch of files where only one
	    or two differs from the prior zip file means that Git will properly
	    reference the same file multiple times. Unfortunately, GitHub does not provide
	    an interface for reviewing statistics of Wikis in the same way that
	    they do for regular repositories. We can, however, review our
	    repository size from within the local repository by running the
	    count-objects Git subcommand. As an example, I uploaded a ZIP file
	    with two images inside of it. I then use the
	    count-objects command and see this:</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ git gc
		...
		$ git count-objects -v
		count: 0
		size: 0
		in-pack: 11
		packs: 1
		size-pack: 2029
		prune-packable: 0
		garbage: 0
		size-garbage: 0</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Inspecting the first ZIP file, I see these statistics about it.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ unzip -l ~/Downloads/Photos\ \(4\).zip
		Archive:  /Users/xrdawson/Downloads/Photos (4).zip
		Length     Date   Time    Name
		--------    ----   ----    ----
		1189130  01-01-12 00:00   IMG_20130704_151522.jpg
		889061  01-01-12 00:00   IMG_20130704_174217.jpg
		--------                   -------
		2078191                   2 files</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Now, let’s use another ZIP file, with the same two files present but
	    now with an additional image file added.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">unzip -l ~/Downloads/Photos\ \(5\).zip
		Archive:  /Users/xrdawson/Downloads/Photos (5).zip
		Length     Date   Time    Name
		--------    ----   ----    ----
		1189130  01-01-12 00:00   IMG_20130704_151522.jpg
		566713  01-01-12 00:00   IMG_20120825_164703.jpg
		889061  01-01-12 00:00   IMG_20130704_174217.jpg
		--------                   -------
		2644904                   3 files</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Then, I upload the second ZIP file. If I re-run the count-object
	    command (after running <code>git gc</code>, a command which packs files
	    efficiently and makes our output more human readable), I see this:</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ git gc
		...
		$ git count-objects -v
		count: 0
		size: 0
		in-pack: 17
		packs: 1
		size-pack: 2578
		prune-packable: 0
		garbage: 0
		size-garbage: 0</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Notice that our packed size has only changed by about half a MB, which
	    is the compressed size of the additional third file, but more
	    importantly, there was no impact from the other two files on our
	    repository size, even though they were added at different paths.</p>
	</div>
	<div class="paragraph">
	  <p>If we upload the secondary file yet again, we will regenerate and
	    commit a new version of the <code>Review.md</code> file, but no new files will
	    need to be created inside our Git repository object store from the
	    images directory (even though their paths have changed), so our
	    impact on the repository will be minimal.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ git gc
		...
		$ git count-objects -v
		count: 0
		size: 0
		in-pack: 21
		packs: 1
		size-pack: 2578
		prune-packable: 0
		garbage: 0
		size-garbage: 0</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>As you can see, our packed-size has barely changed, an indication that
	    the only changes were a new Git tree object and commit object. We
	    still do have the files located in our repository at a variety of
	    paths so our review pages will work no matter what revision we are accessing.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ find images
		images
		images/7507409915d00ad33d03c78af0a4004797eec4b4
		images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20120825_164703.jpg
		images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20130704_151522.jpg
		images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20130704_174217.jpg
		images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75
		images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20120825_164703.jpg
		images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20130704_151522.jpg
		images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20130704_174217.jpg
		images/b4be28e5b24bfa46c4942d756a3a07efd24bc234
		images/b4be28e5b24bfa46c4942d756a3a07efd24bc234/IMG_20130704_151522.jpg
		images/b4be28e5b24bfa46c4942d756a3a07efd24bc234/IMG_20130704_174217.jpg</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Git and Gollum can efficiently store the same file at different paths
	    without overloading the repository.</p>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_reviewing_on_github">Reviewing on GitHub</h3>
	<div class="paragraph">
	  <p>The raison d’etre for this wiki is to annotate a development project.
	    If you follow the instructions and create a new wiki for a
	    repository, you’ll then be able to push up the changes we’ve made
	    using our image.rb script. Once you have created a new wiki, look
	    for a box on the right that says "Clone this wiki locally," as seen in <a href="#gollum_git_clone_url">Getting the clone URL for our wiki</a>.</p>
	</div>
	<div id="gollum_git_clone_url" class="imageblock">
	  <div class="content">
	    <img src="images/btwg_03in05.png" alt="btwg 03in05">
	  </div>
	  <div class="title">Figure 5. Getting the clone URL for our wiki</div>
	</div>
	<div class="paragraph">
	  <p>Copy that link, and then enter a terminal window where we can then add a remote
	    URL to our local repository which allows us to synchronize our
	    repositories and publish our images into GitHub. Gollum wikis have a
	    simple URL structure based on the original clone URL: just add the
	    word <code>.wiki</code> to the end of the clone URL (but before the final <code>.git</code>
	    extension). So, if our original clone URL of the repository is
	    <code>git@github.com:xrd/webiphany.com.git</code> our clone URL for the
	    associated wiki will be <code>git@github.com:xrd/webiphany.com.wiki.git</code>.
	    Once we have the URL, we can add it as a remote to our local
	    repository using the following commands.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-bash" data-lang="bash">$ git remote add origin git@github.com:xrd/webiphany.com.wiki.git
		$ git pull # This will require us to merge the changes...
		$ git push</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>When we pull, we will be asked to merge our changes since GitHub
	    created a <em>Home.md</em> file that did not exist in our local repository.
	    We can just accept the merge as is. The <code>git push</code> publishes our
	    changes. If we then visit the wiki, we’ll see an additional file
	    listed under the pages sidebar to the right. Clicking the Review
	    page, as in <a href="#images_displayed_within_a_gollum_wiki">An image review page</a>, we can see the images we’ve added most recently.</p>
	</div>
	<div id="images_displayed_within_a_gollum_wiki" class="imageblock">
	  <div class="content">
	    <img src="images/btwg_03in06.png" alt="btwg 03in06">
	  </div>
	  <div class="title">Figure 6. An image review page</div>
	</div>
	<div class="paragraph">
	  <p>Not sure why our designer is providing us with an image of a couch,
	    but I am sure he has his reasons.</p>
	</div>
	<div class="paragraph">
	  <p>Once we have published the file, we can click the Review link in the
	    sidebar to see the most current version of the Review page. We also
	    can review the revisions of this file by clicking the "3 Commits"
	    (or whatever number of commits have occurred with this file)
	    link right underneath the page title. Jumping onto that page shows us
	    the full history of this file, as shown in <a href="#a_view_on_the_revisions_from_within_github">Wiki history review via the Commit Log</a>.</p>
	</div>
	<div id="a_view_on_the_revisions_from_within_github" class="imageblock">
	  <div class="content">
	    <img src="images/btwg_03in07.png" alt="btwg 03in07">
	  </div>
	  <div class="title">Figure 7. Wiki history review via the Commit Log</div>
	</div>
	<div class="paragraph">
	  <p>Clicking on any of the SHA hashes will display the page at that
	    revision in our history and show us the state of the document at any given
	    moment in history. Unfortunately, jumping back and forth between
	    revisions requires two clicks, one from the review page to the list of
	    revisions, and then another click to jump into the revision we want,
	    but this permits us to review changes between the comps provided from
	    our designer.</p>
	</div>
	<div class="paragraph">
	  <p>It would be nice if GitHub provided a simple way to jump
	    from a revision to the parent (older) revision, but they don’t expose
	    this in their site as of this writing. We can fix this, however, by generating
	    our own special link inside the review page itself which will
	    magically know about how to navigate to a previous version of the page.</p>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_improving_revision_navigation">Improving Revision Navigation</h3>
	<div class="paragraph">
	  <p>In our example, we only have three revisions right now, and all share the same commit
	    message ("Adding new images"). This is not very descriptive and makes
	    it challenging to understand the differences between revisions,
	    critical when we are trying to understand how things have changed
	    between comps. We can improve this easily.</p>
	</div>
	<div class="paragraph">
	  <p>First, let’s add a commit message field to our upload form.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
		&lt;body&gt;
		&lt;!-- message --&gt;
		&lt;form method='POST' enctype='multipart/form-data' action='/unpack'&gt;
		Choose a zip file:
		&lt;input type='file' name='zip'/&gt;
		&lt;input type='text' name='message' placeholder='Enter commit message'/&gt;
		&lt;input type='submit' name='submit'&gt;
		&lt;/form&gt;
		&lt;/body&gt;
		&lt;/html&gt;</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Then, let’s adjust the commit message inside our <code>image.rb</code> script,
	    which is a one line change to the options hash, setting the value of
	    it to the parameter we are now passing in for "commit".</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-ruby" data-lang="ruby">  ...
		options[:committer] = { :email =&gt; @email, :name =&gt; @name, :time =&gt; Time.now }
		options[:message] = params[:message]
		options[:parents] = @repo.empty? ? [] : [ @repo.head.target ].compact
		...</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Now, if our designer posts a new version of the UI comps, they can
	    specify what changes were made, and we have a record of that in our
	    change log, exposed on the revisions section of our wiki hosted on GitHub.</p>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_fixing_linking_between_comp_pages">Fixing Linking Between Comp Pages</h3>
	<div class="paragraph">
	  <p>We noted that there is no quick way to jump between comps once we are
	    inside a review revision. However, if you recall we used the parent
	    SHA hash to build out our image links. We can use this to build out a
	    navigation links inside our comp page when we are on a revision page while
	    viewing the history.</p>
	</div>
	<div class="paragraph">
	  <p>Again, it is a simple change: one line within the <code>write_review_file</code>
	    method. After the block which creates each link to the image files,
	    add a line which builds a link to the parent document
	    via its SHA hash using the parent SHA found in our Rugged object under
	    <code>@repo.head.target</code>. This link will allow us to navigate to prior
	    revisions in our history.</p>
	</div>
	<div class="listingblock">
	  <div class="content">
	    <pre class="highlight"><code class="language-ruby" data-lang="ruby">  ...
		files.each do |f|
		contents += "### #{f} \n[[#{dir}/#{f}]]\n\n"
		end
		contents += "[Prior revision (only when viewing history)](#{@repo.head.target})\n\n"

		File.write review_filename, contents
		oid = @repo.write( contents, :blob )
		...</code></pre>
	  </div>
	</div>
	<div class="paragraph">
	  <p>Now, when we view the Review file history, we see a link to each prior
	    version. Is it possible to provide a link to the next version in our
	    history? Unfortunately, we have no way to predict the SHA hash of the
	    next commit made to the repository, so we cannot build this link
	    inside our <code>Review.md</code> file with our ruby script. However, we do get
	    something just as good for free because we can simply use the back
	    button to jump back to the prior page in the history stack of our
	    browser. We might try to get clever
	    and use a link with JavaScript to call "window.history.back()" but
	    Gollum will foil this attempt by stripping JavaScript from rendered
	    markup files. This is generally is a good thing, as we don’t want to
	    permit rogue markup inside our wiki pages, but it does limit our
	    options in this situation.</p>
	</div>
	<div class="paragraph">
	  <p>Unfortunately, these links do not work when you are viewing the review file itself
	    (clicking on them brings you to a page which asks you to create this
	    as a new page). Gollum, unlike Jekyll, does not support Liquid
	    tags which would permit building a link using the username and
	    repository. Right now we don’t have access to these variables, so our
	    link needs to be relative, which works when we are in history review,
	    but not in the normal review. It does not affect viewing the files so
	    this would require educating your stakeholders on the limitations of
	    this link.</p>
	</div>
      </div>
      <div class="sect2">
	<h3 id="_summary">Summary</h3>
	<div class="paragraph">
	  <p>In this chapter we learned how to create a Gollum wiki from
	    scratch, both on GitHub and as a fresh repository from the comman
	    line. We then looked at the different ways to use the <code>gollum</code> command
	    line tool and learned why this is a nice option when we want to run
	    our own Gollum server. Finally, we built a customized Gollum
	    image-centric editor using the Rugged and Sinatra Ruby libraries.</p>
	</div>
	<div class="paragraph">
	  <p>In the next chapter we’ll switch gears completely, and build a GUI
	    application for searching GitHub issues. And we’ll do it in Python.</p>
	</div>
      </div>
    </div>
  </div>
</div>
