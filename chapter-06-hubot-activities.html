<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>CoffeScript, Hubot and the Activities API</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove the comments around the @import statement below when using this as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
#map_canvas img,#map_canvas embed,#map_canvas object,.map_canvas img,.map_canvas embed,.map_canvas object{max-width:none!important}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
.antialiased,body{-webkit-font-smoothing:antialiased}
img{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{display:inline-block;color:rgba(0,0,0,.8);font-size:.75em;line-height:1.4;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:-.15em .15em 0 .15em;padding:.2em .6em .2em .5em;vertical-align:middle;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.05em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.spread{width:100%}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1{padding-right:.75em;font-weight:bold}
td.hdlist1,td.hdlist2{vertical-align:top}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none}
span.footnote,span.footnoteref{vertical-align:super;font-size:.875em}
span.footnote a,span.footnoteref a{text-decoration:none}
span.footnote a:active,span.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em;line-height:1.3;font-size:.875em;margin-left:1.2em;text-indent:-1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
h1,h2{letter-spacing:-.01em}
dt,th.tableblock,td.content{text-rendering:optimizeLegibility}
p,td.content{letter-spacing:-.01em}
p strong,td.content strong{letter-spacing:-.005em}
p,blockquote,dt,td.content{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img{page-break-inside:avoid}
thead{display:table-header-group}
img{max-width:100%!important}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="Hubot">CoffeScript, Hubot and the Activities API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Though the phrase has now been removed from their marketing materials,
GitHub used to call itself a tool for "social coding." This idea is
still central to the services GitHub provides, intimate access to the
social layer inside of GitHub through the Activity API.</p>
</div>
<div class="paragraph">
<p>In this chapter we&#8217;ll investigate the Activity API by extending a chat
robot. You might find it odd that a robot, generally considered an anti-social
invention despite all best attempts, would play nicely with a social
API, but this is a social robot. GitHubbers use an
extensible chat robot called Hubot to record and automate their tasks,
and to have fun on the Internet. If there were any robot suited for
interacting with the GitHub Activity API, it&#8217;s Hubot, described on the
site hubot.github.io as "a customizable, kegerator-powered life
embetterment robot."</p>
</div>
<div class="sect2">
<h3 id="_the_activities_api">The Activities API</h3>
<div class="paragraph">
<p>The Activities API includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>notifications (comments issued to users through various events)</p>
</li>
<li>
<p>stargazing tools (Facebook has "likes" while GitHub has "stars" to indicate approval or interest)</p>
</li>
<li>
<p>watching (a way to track GitHub data)</p>
</li>
<li>
<p>events (a higher level activity stream useful for following actions of users).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The Activity API section also includes "feeds." While feeds are
grouped within the Activity API, they are not programmatic in the same
way that an API is, and we won&#8217;t cover them in depth here.  Feeds are
actually Atom feeds and not interactive beyond that. Atom feeds are
similar to RSS feeds: a static feed you can subscribe to with an Atom
client.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_planning_for_pr_satisfaction_guaranteed">Planning for PR Satisfaction Guaranteed</h3>
<div class="paragraph">
<p>We are going to build an extension to Hubot. When we are done, Hubot
will be transformed into a robot that..</p>
</div>
<div class="ulist">
<ul>
<li>
<p>listens for pull request events from GitHub by subscribing to
notifications using the GitHub Activities API</p>
</li>
<li>
<p>invites people in the chat room to comment on those pull requests</p>
</li>
<li>
<p>guarantees that communication between it and GitHub is securely
delivered (with an unfortunate bug as caveat)</p>
</li>
<li>
<p>retrieves vital information from an external service (the Slack.com API)</p>
</li>
<li>
<p>has functionality fully described by automated tests.</p>
</li>
<li>
<p>allows easy simulation of inputs and outputs which map to the
inputs and outputs it gets from APIs and services.</p>
</li>
<li>
<p>runs with ease host on a major Paas (Heroku)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hubot provides the skeleton for our chat robot. We&#8217;ll add the above
functionality to Hubot and see how easy it is to combine these
features into a coherent whole that solves a real problem.</p>
</div>
<div class="sect3">
<h4 id="_considerations_and_limitations">Considerations and Limitations</h4>
<div class="paragraph">
<p>If you want stability with your Hubot, you need to host it on a
server. Hubot is written in NodeJS and requires a hosting service that
supports NodeJS. Our Hubot needs to sit on a public IP address (not
inside the firewall) because we receive notifications from GitHub. It
is not strictly required that you host Hubot on a public server; if
your Hubot does not need to receive requests from the outside world,
you can host on a private internal server as well.</p>
</div>
<div class="paragraph">
<p>The simplest and cheapest hosting service for Hubot is Heroku. Once we
generate our Hubot, we can simply do a git-push into Heroku to publish
our chat robot for free. We&#8217;ll show these steps later in the chapter.</p>
</div>
<div class="paragraph">
<p>Hubot works with many chat endpoints. Your Hubot can connect to almost
any popular chat service or protocol: IRC, XMPP and many commercial
services like Gchat, Basecamp, even Twitter. Slack is a relatively new
entrant into the world of chat services, but despite its youth, the
Slack API is solid and connecting third party clients to the Slack
service is simple and straightforward. We&#8217;ll use Slack as our chat endpoint.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s create our Hubot and configure it to use Slack.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_vanilla_hubot">Creating a Vanilla Hubot</h4>
<div class="paragraph">
<p>To build a Hubot you will need a working NodeJS installation, as
specified in the NodeJS appendix. The following commands create a
directory with a bare bones Hubot.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ npm install -g generator-hubot <b class="conum">(1)</b>
$ mkdir slacker-hubot <b class="conum">(2)</b>
$ cd slacker-hubot/
$ yo hubot <b class="conum">(3)</b>
$ npm install hubot-slack --save <b class="conum">(4)</b></pre>
</div>
</div>
<div class="paragraph">
<p>You may not be familiar with these commands, so let&#8217;s go over the
important ones.</p>
</div>
<div class="colist arabic">
<ol>
<li>
<p>NPM is the tool which installs packages for NodeJS (documented in
the NodeJS appendix). The <code>npm install -g
generator-hubot</code> command installs a command line tool called yeoman
and a plugin for yeoman that scaffolds hubot.</p>
</li>
<li>
<p>You should create a new directory and enter it so that when you
create your Hubot you can store it entirely in its own space.</p>
</li>
<li>
<p>You run the generator using the <code>yo hubot</code> command. This builds
out the set of files for a minimal Hubot.</p>
</li>
<li>
<p>We then install the slack adapter and save the package to the
<code>package.json</code> file.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now that we have a simple Hubot created we need to create the Slack site
where our Hubot will live.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_slack_account">Creating a Slack Account</h4>
<div class="paragraph">
<p>Going to slack.com starts you on the process to create your own Slack
site. You&#8217;ll need to step through creating an account. Slack sites are
segmented by organization, and you&#8217;ll want to establish a URL prefix
for your Slack site. Typically this is the name of your organization.</p>
</div>
<div class="sect4">
<h5 id="_naming_the_channel">Naming the channel</h5>
<div class="paragraph">
<p>Once you have your slack site created, you need to create a channel.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hubot-create-channel.png" alt="Creating the #generic channel">
</div>
</div>
<div class="paragraph">
<p>You can name the channel anything you want, but it is often a good
mnemonic to use a name which suggests this is a channel where more
serious work gets done. You could use a name like "PR Discussion" to
indicate this is the channel where PRs are discussed. To keep things
simple, we will use the name "#general". Once you click on
the link to create a channel, you&#8217;ll see a popup asking for the name
and an optional description. After you have created the channel,
you will see a link to "Add a service integration."</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hubot-add-service-integration.png" alt="Adding service integrations to Slack">
</div>
</div>
<div class="paragraph">
<p>Slack supports many different service integrations, and one of them is
Hubot.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hubot-choose-hubot-integration.png" alt="Choosing Hubot from the man Slack integration options">
</div>
</div>
<div class="paragraph">
<p>Choosing Hubot takes you to a settings screen for your Hubot integration.</p>
</div>
<div class="paragraph">
<p>Slack automatically generates an authentication token for you.
This token is used to verify the connection from your Hubot. This
token can be revoked, and in fact the token from the image below
has been revoked and can no longer be used to authenticate into
Slack. If you ever accidentally publicize this token, you can easily
revoke and reassign a token to your Hubot on this screen.</p>
</div>
<div class="paragraph">
<p>You will also need to specify a name. Use "probot" and if you&#8217;d like,
change the avatar associated with the Hubot.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hubot-choose-username.png" alt="Choose Hubot's name">
</div>
</div>
<div class="paragraph">
<p>Make sure you save your integration before continuing.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_running_hubot_locally">Running Hubot Locally</h4>
<div class="paragraph">
<p>Eventually you will want to run your Hubot on a server, but Hubot can
run from a laptop behind a firewall as well. At the beginning of
development, while testing and developing your bot and the changes are
fast and furious, you probably want to run Hubot
locally. In fact, Hubot behind a firewall is almost identical in its
feature set with one major exception: anything behind the firewall is
inaccessible, obviously, to external services. We are eventually going
to be configuring GitHub to send events to us when a pull request is
created, and Hubot behind the firewall cannot receive those
events. But, for almost all other functionality, running Hubot locally
speeds up development cadence.</p>
</div>
<div class="paragraph">
<p>To run your bot locally, make sure that you specify the variables on
the command line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ HUBOT_SLACK_TOKEN=xoxb-3295776784-nZxl1H3nyLsVcgdD29r1PZCq \
./bin/hubot -a slack</pre>
</div>
</div>
<div class="paragraph">
<p>This command runs the hubot script with the slack adapter. The slack adapter
knows how to interact with the Slack.com service. It requires an
authentication token, and this is provided via the environment
variable at the beginning of the line.</p>
</div>
<div class="sect4">
<h5 id="_a_first_conversation">A First Conversation</h5>
<div class="paragraph">
<p>Your bot should be setup and waiting in the #general room inside your
Slack site. Go to the #general room. Then, you can test that hubot
is properly connectd by typing in the name of your Hubot
and then a command like <code>the rules</code>. For example, if our Hubot is
named <code>probot</code>, then we would type <code>probot the rules</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hubot-verify.png" alt="Hubot telling us the rules">
</div>
</div>
<div class="paragraph">
<p>We see that our hubot printed out the rules it
abides by (published originally by Isaac Asimov in his "Runaround"
short story in 1942).</p>
</div>
</div>
<div class="sect4">
<h5 id="_exploring_the_hubot_vocabulary">Exploring the Hubot Vocabulary</h5>
<div class="paragraph">
<p>Hubot out of the box supports many commands. To get a list, type "help".</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hubot-help.png" alt="The built-in Hubot commands">
</div>
</div>
<div class="paragraph">
<p>The <code>pug me</code> command is a favorite. Many people new to Hubot
quickly get sucked into spending hours looking at cute pictures of
pugs. Beware!</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_installation_on_heroku">Installation on Heroku</h3>
<div class="paragraph">
<p>Now that we&#8217;ve successfully started our hubot locally, we can move it
to Heroku and keep it running even when our laptop is turned off.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_heroku">Setting up Heroku</h4>
<div class="paragraph">
<p>Heroku requires registration before using it. Heroku offers free plans and everything
we&#8217;ll do here can be done using a free plan. Once you have created an
acccount, install the heroku toolbelt found here:
<a href="https://toolbelt.heroku.com/" class="bare">https://toolbelt.heroku.com/</a>. The toolbelt provides a set
of tools useful for managing Heroku applications. You will need to
have Ruby setup as explained in the first chapter.</p>
</div>
<div class="paragraph">
<p>If your chatbot is working per the instructions given in the previous
section, then it is almost ready to deploy to Heroku. You&#8217;ll need to
add the same environment variable using the heroku tools. In addition
to the authentication token for slack, you will need to configure a
URL for your site. Heroku will generate a URL for you from the name of
your project (in this case <code>inqry-chatbot</code>) so as long as the name has
not been claimed already by someone else, you can name it as you will.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ heroku create inqry-chatbot
$ heroku config:add HEROKU_URL=https://inqry-chatbot.herokuapp.com/
$ heroku config:add HUBOT_SLACK_TOKEN=xxbo-3957767284-ZnxlH1n3ysLVgcD2dr1PZ9Cq
$ git push heroku master
Fetching repository, done.
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 317 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)

-----&gt; Node.js app detected
-----&gt; Requested node range:  0.10.x
...
-----&gt; Compressing... done, 6.8MB
-----&gt; Launching... done, v9
       https://inqry-chatbot.herokuapp.com/ deployed to Heroku

To git@heroku.com:inqry-chatbot.git
   d32e2db..3627218  master -&gt; master</pre>
</div>
</div>
<div class="paragraph">
<p>If you need to troubleshoot issues with your Hubot, you can always run
the heroku log command to view logs for your application <code>heroku logs -t</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ heroku logs -t
2014-11-18T07:07:18.716943+00:00 app[web.1]: Successfully 'connected'
as hubot
2014-11-18T07:07:18.576287+00:00 app[web.1]: Tue, 18 Nov 2014 07:07:18
GMT connect deprecated limit: Restrict request size at location of
read at
node_modules/hubot/node_modules/express/node_modules/connect/lib/middleware/multipart.js:86:15
...</pre>
</div>
</div>
<div class="paragraph">
<p>When you send commands into your chat room you will notice events
inside of Heroku. This is a good way to verify that your bot is wired
into Slack properly.</p>
</div>
<div class="paragraph">
<p>You might also want to publish this repository into GitHub. Heroku,
as a part of hosting your live application, also hosts the full Git
repository of your Hubot (Hubot, as friendly as it tries to be, is
just another NodeJS application in the end). Heroku can host the
entirety of the source code for your Hubot for you, but does not have
the additional tools, like user management, that GitHub does. For this
reason, use your GitHub account as your code repository, the place where
team members develop new features of your chat bot. Build and test
locally, and then push into Heroku using the ease of the Git workflow
as a deployment layer.</p>
</div>
<div class="paragraph">
<p>Now that we have created and installed Hubot, let&#8217;s look at the
Activities API and determine how we want to code our extension.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_activities_api_overview">Activities API Overview</h3>
<div class="paragraph">
<p>The Activities API centers around notifications: notifications are similar
to the notifications you see on social networking sites, events that
occur which document important points of interest inside a timeline of
activity. GitHub activity events are often tied to important
milestones inside of a developer&#8217;s day, activities like pushing
commits into the main remote repository, asking questions on
discussion threads associated with a repository, or assigning issues
to a developer for review.</p>
</div>
<div class="paragraph">
<p>These notifications are accessible to team members without
programmatically accessing the GitHub API. Team members are notified
of events inside of their workflow using email based on several
rules. GitHub will automatically send out notification emails when a
user has watched a repository and issues or comments are added, a pull
request is made, or there are comments made on a commit. In addition,
even if a user has not watched a repository, they will be notified if
that user is <strong>@mentioned</strong> (prefixing the <code>@</code> character to a team
member&#8217;s name inside a comment), when an issue is assigned to them, or
when that user participates in a discussion associated with any
repository.</p>
</div>
<div class="paragraph">
<p>The GitHub policy for notification is definitely to err on the side of
being overly verbose. Many people live in their email, and making sure
that all important activities are distributed to the right people
involved makes sense, and GitHub has a good set of rules for making
sure the correct notifications get to the right parties.</p>
</div>
<div class="paragraph">
<p>Email does falter as a to-do list, however, and at times the ease in
which email can be delivered breeds a secondary problem: overwhelm. It
can be very easy to lose focus (vital to building software) when you
are constantly context switching by checking email, and notifications
can often fly by. In addition, email is privately directed and
prevents easily collaboration; generally people don&#8217;t share email
inboxes. Let&#8217;s extend our Hubot to help us resolve these problems by taking
our GitHub notifications into a shared and "opt-in when you are logged-in"
communication channel.</p>
</div>
<div class="sect3">
<h4 id="_writing_a_hubot_extension">Writing a Hubot Extension</h4>
<div class="paragraph">
<p>Hubot extensions are written in either JavaScript or
CoffeeScript. CoffeeScript is a intermediate language which compiles
directly to JavaScript. Many people prefer writing in CoffeeScript
because it has a cleaner syntax and writes "safer"
JavaScript (the syntax helps you avoid common tricky pitfalls in the
JavaScript language, like what "this" refers to).
CoffeeScript is a indentation based language (much like
Python) and after the initial learning curve, can feel easier to read
than JavaScript, especially when you have many nested function
callbacks (common in JavaScript programming); it is easier to see
where a function begins and ends given the indentation levels. Hubot
is itself written in CoffeeScript and we&#8217;ll write our extension in
CoffeeScript as well.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
CoffeeScript is a language where indentation is important. For
readability purposes, when we display a snippet of code from a longer
file, there are times where we have changed the indentation of that
snippet and removed the initial indentation. If you were to copy the
code without realignment, the snippet would not work until you
re-indented it to fit the context into which it sits.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Hubot extension module format is exceedingly simple. You write
JavaScript modules (using the <code>export</code> syntax) and Hubot passes you in
a robot object which you program using several API methods.</p>
</div>
<div class="paragraph">
<p>There are a few concepts useful to programming Hubot. You can find
an example of each of these methods inside the <code>example.coffee</code> file
inside the scripts directory.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hubots have a "brain". This is an internal state object, which means
these values persist across chat messages. This state is not
persisted into a database by default, so this state is not restored
if you restart Hubot. However, a persistence mechanism is exposed
via redis, though this is optional and requires configuration. The
brain is they way you set and get values which are saved across
discrete messages.</p>
</li>
<li>
<p>Hubots have different respose mechanisms. They can choose to respond
only when they hear exact phrases or when keywords are found in any
message, and you don&#8217;t need to do the grunt work inside your code to
determine the differences between these communication types.</p>
</li>
<li>
<p>Hubots include an HTTP server. You might need your Hubot to accept
requests from additional services beyond the chat service, and Hubot
makes it easy to accept these kinds of requests.</p>
</li>
<li>
<p>Hubot has a built in HTTP client. You can easily access HTTP
resources within Hubot; many popular extensions to Hubot access a
web service when Hubot receives a request.</p>
</li>
<li>
<p>Hubot commands can include parameters. You can tell a Hubot to
do something multiple times and write a generic function which
accepts options.</p>
</li>
<li>
<p>Hubots can handle events. Each chat service has a generalized set of
events that are normalized to a common API. Hubots can be programmed
to interact with these events. For example, Hubots can perform
actions when a room topic changes or when users leave rooms.</p>
</li>
<li>
<p>Hubots can handle generic errors at the top level. Hubot can be
programmed with a catch-all error handler so that no matter where
your code failed, you can catch it without crashing your bot.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hubot will use the first five of these features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We will use the Hubot brain to store a PR review request. If Hubot
asks a user to review a PR, it needs to keep track of this so that
when the user responds it has some context of the request.</p>
</li>
<li>
<p>We will use the respond method to program our Hubot to handle a
request when a user accepts or declines the review request.</p>
</li>
<li>
<p>We will use the HTTP server to accept PR notifications from GitHub
webhooks.</p>
</li>
<li>
<p>We will use the HTTP client to get a list of users from Slack.</p>
</li>
<li>
<p>We will use the parameterization of requests to Hubot to retrieve
the specific pull request ID from a chat user message.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are examples of the other two features (events and generic
errors) inside the examples script that ship with the Hubot source
code but we won&#8217;t use those APIs in our Hubot.</p>
</div>
</div>
<div class="sect3">
<h4 id="_code_reviews_via_pull_requests">Code Reviews via Pull Requests</h4>
<div class="paragraph">
<p>As we&#8217;ve seen in other chapters, pull requests are the mechanism used
on GitHub to easily integrate code changes into a project. Contributors
either fork the master repository and then issues a pull request against that
repository, or, if they have write permission to the main
repository, make a "feature" branch and then issue a pull request
against the "master" branch.</p>
</div>
<div class="paragraph">
<p>Pull requests often come with a chat message indicating several people
who should review the request. This tribal knowledge about who should
be involved is only in the head of the developer who created the
code. It could be that they invited the correct people. Or, it could
be that they invited the people who they prefer to review their code
for various (and completely rational reasons). This can be an
effective way to engage the right people around a new piece of
code.</p>
</div>
<div class="paragraph">
<p>And, inviting reviewers this way can have downsides as well: if the
person is otherwise engaged, pull requests can linger when a
notification email goes unread. And, there is good research to
indicate that the best performing teams are those who share all tasks
and responsibilities equally. It often does not scale to ask everyone
to participate in all code reviews associated with a pull
request. But, it might be the case that randomly selecting developers
involved in a project is a better (and more efficient) way to review
code than asking the developer who created the code to determine these people.</p>
</div>
<div class="paragraph">
<p>Hubot will assign active chat room users to do code
reviews when a new pull request is created. We will use the GitHub
Activities API to subscribe to pull request events. When Hubot
becomes aware that a pull request needs review, it will randomly
assign a user in the chat room to do the review and then ask that user
if they want to accept the challenge. If they accept, we will note
that in the pull request comments.</p>
</div>
<div class="sect4">
<h5 id="_extension_boilerplate">Extension Boilerplate</h5>
<div class="paragraph">
<p>We will start writing our extension by defining the high level
communication format we expect from our users. Our script has a simple
vocabulary: look for responses indicating acceptance or refusal of our
review requests. Our extension script should be in the
<code>scripts</code> directory and named <code>pr-delegator.coffee</code>. This is just the
back and forth we will be having with users; we are not yet writing
any code to handle the pull request notifications.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">module.exports = (robot) -&gt; <b class="conum">(1)</b>
       robot.respond /accept/i, (res) -&gt; <b class="conum">(2)</b>
               accept( res )
       robot.respond /decline/i, (res) -&gt; <b class="conum">(3)</b>
               decline( res )
       accept = ( res ) -&gt; <b class="conum">(4)</b>
               res.reply "Thanks, you got it!"
               console.log "Accepted!" <b class="conum">(5)</b>
       decline = ( res ) -&gt; <b class="conum">(6)</b>
               res.reply "OK, I'll find someone else"
               console.log "Declined!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a dense piece of code and can be confusing if you are new to
CoffeeScript. At the same time, hopefully you will agree this is
amazingly powerful code for such a small snippet after reading these notes.</p>
</div>
<div class="colist arabic">
<ol>
<li>
<p>All NodeJS modules work start by defining entrypoints using the
<code>exports</code> syntax. This code defines a function that expects a single
parameter; when the function is executed, the parameter will be called
robot. The Hubot framework will pass in a robot object for us that we
will program further down.</p>
</li>
<li>
<p>The Hubot API defines a method on the robot object called
<code>respond</code> which we use here. It takes two parameters: a regular
express to match against and a function which receives an instance of
the chat response object (called <code>res</code> here). The second line uses
the API for this response object to call a method <code>accept</code> with the
response object. We define accept in a moment.</p>
</li>
<li>
<p>We setup a response matcher for a "decline" response.</p>
</li>
<li>
<p>Now we define the <code>accept</code> method. The accept method receives the
response object generated by the Hubot framework and calls the <code>reply</code>
method which, you guessed it, sends a message back into the chat
channel with the text "Thanks, you got it!".</p>
</li>
<li>
<p>The accept method then also calls <code>console.log</code> with information
that is displayed on the console from which we started Hubot. This is
a simple way for us to assure everything worked correctly; if we don&#8217;t
see this message, our code before this was broken. The <code>console.log</code>
is not visible to any users in the channel. It is good practice to
remove this code when you finalize your production code, but if you
forget, it won&#8217;t affect anything happening in the channel.</p>
</li>
<li>
<p>We then define the <code>decline</code> method using the same APIs as for the
<code>accept</code> method.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If Hubot is running, you will need to restart it to reload any
scripts. Kill Hubot (using Ctrl-C), and then restart it, and then
play with commands inside your Slack site. Entering the commands
<code>probot accept</code> and <code>probot decline</code> and you&#8217;ll see Hubot
respoding inside the channel. You&#8217;ll also see the message <code>Accepted!</code> or
<code>Declined!</code> printed to the console on which Hubot is
running.</p>
</div>
</div>
<div class="sect4">
<h5 id="_writing_tests_for_hubot_extensions">Writing Tests for Hubot Extensions</h5>
<div class="paragraph">
<p>Now that we have the basics of our Hubot working, let&#8217;s make sure we
certify our code with some tests. We&#8217;ll use the Jasmine testing
framework for NodeJS. It offers an elegant behavior driven testing
syntax where you specify a behavior as the first parameter to an <code>it</code>
function, and as a second parameter, a function which is run as the
test itself. Jasmine manages running each <code>it</code> call and displays a
nice output of passing and failed tests at the end of your
run. Jasmine tests are typically written in JavaScript, but the latest versions of
Jasmine support tests also written in CoffeeScript. Hubot is written
in CoffeeScript, so let&#8217;s write our tests in CoffeeScript as
well. We need to put our tests inside a
directory called "spec" and make sure our filename ends with
<code>.spec.coffee</code>. Let&#8217;s use <code>spec/pr-delegator.spec.coffee</code> as the
complete filename. Jasmine expects spec files to have <code>.spec.</code> at the
end of their filename (before the extension, either <code>.js</code> or
<code>.coffee</code>); if your filename does not match this pattern Jasmine won&#8217;t
recognize it as a test.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">Probot = require "../scripts/pr-delegator"
Handler = require "../lib/handler"

pr = undefined
robot = undefined

describe "#probot", -&gt;
        beforeEach () -&gt;
                robot = {
                        respond: jasmine.createSpy( 'respond' )
                        router: {
                                post: jasmine.createSpy( 'post' )
                                }
                        }

        it "should verify our calls to respond", (done) -&gt;
                pr = Probot robot
                expect( robot.respond.calls.count() ).toEqual( 2 )
                done()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line in our test requires, or loads, the Hubot extension
module into our test script, giving us a function we save as a Probot
variable. We then create a <code>describe</code>
function which is an organizing function to group tests. <code>describe</code>
functions take an indentifier (in this case <code>#probot</code>) and a function
which contains multiple <code>it</code> calls. In addition, a <code>describe</code> function
can also contain a <code>beforeEach</code> function which configures common
elements inside our <code>it</code> calls; in this case we create a faked robot
object which we will pass into our <code>Probot</code> function call. When we are
running Hubot itself, Hubot creates the robot and passes it into the
<code>Probot</code> function but when we run our tests, we generate a fake one
and query it to make sure that it is receiving the proper
configuration. If we make a change inside our actual Hubot code and
forget to update our tests to verify those changes, our tests will
fail and we&#8217;ll know we need to either augment our tests, or something
broke inside our robot, a good automated sanity check for us when we
are feverishly coding away, animating our helpful Hubot.</p>
</div>
<div class="paragraph">
<p>You should see some similarities between the calls made to our robot
(<code>robot.respond</code> and <code>robot.router.post</code>) and the tests. We setup
"spies" using Jasmine that generate fake function calls capable of
recording any interaction from outside sources (either our production
code or the test code harness). Inside our <code>it</code> call, we
then verify that those calls were made. We use the <code>expect</code> function
to verify that we have made two calls to the <code>respond</code> function
defined on the robot, and that <code>robot.router.post</code> has been called as
well.</p>
</div>
<div class="paragraph">
<p>We need to install Jasmine, and we do this by adding to our
<code>package.json</code> file. Append <code>"jasmine-node": "^1.14.5"</code> to the file,
and make sure to add a comma to the tuple above it. Adding this code
specifies that the minimum version of jasmine node we will use is
"1.14.5".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">...
  "hubot-shipit": "^0.1.1",
  "hubot-slack": "^3.2.1",
  "hubot-youtube": "^0.1.2",
  "jasmine-node": "^2.0.0"
},
"engines": {
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Runing the following commands will then install Jasmine (the library
and a test runner command line tool) and run our tests. We abbreviate
some of the installation output to save space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$ npm install
...
hubot-slack@3.2.1 node_modules/hubot-slack
└── slack-client@1.2.2 (log@1.4.0, coffee-script@1.6.3, ws@0.4.31)
...
$ ./node_modules/.bin/jasmine-node --coffee spec/

.

Finished in 0.009 seconds
1 test, 1 assertions, 0 failures, 0 skipped</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our tests pass and we now have a way to document and verify that our
code does what we think it does.</p>
</div>
</div>
<div class="sect4">
<h5 id="_setting_up_our_webhook">Setting up our webhook</h5>
<div class="paragraph">
<p>We are now in a position to start adding the actual functionality to
our Hubot. Our first requirement is to register for pull request
events. We could do this from within the GitHub website, but another
way is to use the cURL tool to create the webhook from the command
line. In order to do this, we need to first create an authorization
token, and then we can use that token to create a webhook.</p>
</div>
<div class="paragraph">
<p>To create the token, run this command, setting the proper variables
for your username instead of mine ("xrd").</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$ export USERNAME=xrd
$ curl https://api.github.com/authorizations --user $USERNAME --data
'{"scopes":["repo"], "note": "Probot access to PRs" }' -X POST</code></pre>
</div>
</div>
<div class="paragraph">
<p>This call can return in one of three ways. If your username or
password is incorrect, you will get an error response message like
this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "message": "Bad credentials",
  "documentation_url": "https://developer.github.com/v3"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If your username and password are correct and you don&#8217;t have
two-factor authentication turned on, the request will succeed and you
will get back a token inside the JSON response.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "id": 238749874,
  "url": "https://api.github.com/authorizations/9876533",
  "app": {
    "name": "Probot access to PRs",
    "url": "https://developer.github.com/v3/oauth_authorizations/",
    "client_id": "00000000000000000000"
  },
  "token": "fakedtoken1234",
  "hashed_token": "fakedhashedtoken7654",
  ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using two-factor authentication then you will see a
response message like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "message": "Must specify two-factor authentication OTP code.",
  "documentation_url":
  "https://developer.github.com/v3/auth#working-with-two-factor-authentication"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you get this message in response to the prior cURL command, then
you will be receiving a one time password via
your choice of two factor authentication alternative endpoint (either
SMS or a two factor authentication app like Google Authenticator or
recovery codes that you printed out). If you
use text messaging, check your text messages and then resend the
request appending a header using cURL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$ curl https://api.github.com/authorizations --user $USERNAME --data
'{"scopes":["repo"], "note": "Probot access to PRs" }' -X POST
--header "X-GitHub-OTP: 423584"
Enter host password for user 'xrd':</code></pre>
</div>
</div>
<div class="paragraph">
<p>If all these steps complete successfully (regardless of whether you
are using 2-factor auth or not) you will then receive an oauth token.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "id": 1234567,
  "url": "https://api.github.com/authorizations/1234567",
  "app": {
    "name": "Probot access to PRs (API)",
    "url": "https://developer.github.com/v3/oauth_authorizations/",
    "client_id": "00000000000000000000"
  },
  "token": "ad5a36c3b7322c4ae8bb9069d4f20fdf2e454266",
  "note": "Probot access to PRs",
  "note_url": null,
  "created_at": "2015-01-13T06:23:53Z",
  "updated_at": "2015-01-13T06:23:53Z",
  "scopes": [
    "notifications"
  ]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_oauth_token_to_register_for_events">Using the oAuth token to register for events</h4>
<div class="paragraph">
<p>Once this is completed we now have our token which we can use to
create a webhook. Make sure to use the correct repository name and
access token before running the cURL command. We will also need the
endpoint that we created when we published into Heroku (in our case
<code><a href="https://inqry-chatbot.herokuapp.com" class="bare">https://inqry-chatbot.herokuapp.com</a></code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$ REPOSITORY=testing_repostory
$ TOKEN=ad5a36c3b7322c4ae8bb9069d4f20fdf2e454266
$ WEBHOOK_URL=https://inqry-chatbot.herokuapp.com/pr
$ CONFIG=$(echo '{
  "name": "web",
  "active": true,
  "events": [
    "push",
    "pull_request"
  ],
  "config": {
    "url": "'$WEBHOOK_URL'",
    "content_type": "form",
    "secret" : "XYZABC"
  }
}')
$ curl -H "Authorization: token $TOKEN" \
-H "Content-Type: application/json" -X POST \
-d "$CONFIG" https://api.github.com/repos/$USERNAME/$REPOSITORY/hooks
{
  "url": "https://api.github.com/repos/xrd/testing_repostory/hooks/3846063",
  "test_url":
  "https://api.github.com/repos/xrd/testing_repostory/hooks/3846063/test",
  "ping_url":
  "https://api.github.com/repos/xrd/testing_repostory/hooks/3846063/pings",
  "id": 3846063,
  "name": "web",
  "active": true,
  "events": [
    "push",
    "pull_request"
  ],
  "config": {
    "url": "https://inqry-chatbot.herokuapp.com/pr",
    "content_type": "json"
  },
  "last_response": {
    "code": null,
    "status": "unused",
    "message": null
  },
  "updated_at": "2015-01-14T06:23:59Z",
  "created_at": "2015-01-14T06:23:59Z"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a bit of bash cleverness here, but nothing to be overly
disturbed by. We create a few variables which we use in the final
command. Since the $CONFIG variable is particularly long, we use <code>echo</code>
to print out a bunch of information with the webhook URL in the
middle. If you want to see the result of that variable, type <code>echo
$CONFIG</code> and you&#8217;ll notice the snippet <code>&#8230;&#8203; "url":
"https://inqry-chatbot.herokuapp.com/pr" &#8230;&#8203;</code> properly interpolated.</p>
</div>
<div class="paragraph">
<p>Here we use the Heroku API URL as our webhook endpoint. This means we
need to have things hosted on Heroku for the webhook to talk to our
HTTP server properly. We can do some things (like connecting the Hubot to
the Slack service) from behind a firewall and have it talk with other
chat room participants, but any webhook request will fail unless the
chat client is running on a publicly available server.</p>
</div>
<div class="paragraph">
<p>Be careful to make sure you use the <code>content_type</code> set to "form" (which
is the default, so you could leave it blank). Setting this to <code>json</code> will
make it difficult to retrieve the raw body inside your Hubot when the
post request is received and validate the request using a secure
digest. We want to make sure all requests are real requests from GitHub
and not a cracker attempting to maliciously inject themselves into our
conversations. To protect from this possible situation, we verify each
request back into GitHub by using the secret generated
when we created the webhook. We&#8217;ll discuss this in detail later in this
chapter, but for now, establish a secret when you create the hook. A
cracker might be able to guess about where our endpoint exists, but
unless Heroku or GitHub is compromised, they won&#8217;t know our webhook secret.</p>
</div>
<div class="paragraph">
<p>We should update our tests to make sure we anticipate this new
functionality. We will be using the Hubot HTTP server, which
piggybacks on the built in express server running inside of Hubot. Our
new test should reflect that we use the <code>router.post</code> method exposed
to our Hubot, and that it is called once. We add this next test to the
end of our spec file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">it "should verify our calls to router.post", (done) -&gt;
        pr = Probot robot
        expect( robot.router.post ).toHaveBeenCalled()
        done()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This additional test will fail should we run it. Now we can add to our
Hubot and have it handle webhook callbacks from GitHub. Add this to
the end of the file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">	robot.router.post '/pr', ( req, res ) -&gt;
			  console.log "We received a pull request"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if we run our tests, they all pass. If they do, publish our new
version of the app into Heroku. We&#8217;ll omit this step in the future,
but if you want to receive pull requests on the router you have setup,
remember that you need to publish your files into Heroku so the
endpoint is public.</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>$ ./node_modules/.bin/jasmine-node --coffee spec/
..
$ git commit -m "Working tests and associated code" -a
...
$ heroku push

Finished in 0.009 seconds
2 tests, 2 assertions, 0 failures, 0 skipped
$ git push heroku master
Fetching repository, done.
Counting objects: 5, done.
Delta compression using up to 8 threads.
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We now have an end-to-end Hubot setup, ready to receive webhook
notifications.</p>
</div>
</div>
<div class="sect3">
<h4 id="_triggering_real_pull_requests">Triggering Real Pull Requests</h4>
<div class="paragraph">
<p>We can now start testing our Hubot with real GitHub
notifications. First, let&#8217;s set up a repository which we can use for
testing. Creating the new repository on GitHub is a quick task if we
use the <code>hub</code> tool described in the previous chapter on Jekyll.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ mkdir testing_repository
$ cd testing_repository
$ git init
$ touch test.txt
$ git add .
$ git commit -m "Initial checkin"
$ hub create
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can create a real pull requests for our repository from the
command line and test our Hubot. A typical pull request flow looks
like the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new branch</p>
</li>
<li>
<p>Add new content</p>
</li>
<li>
<p>Commit the content</p>
</li>
<li>
<p>Push the new branch into GitHub</p>
</li>
<li>
<p>Issue a pull request.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All of this can be automated using a combination of git commands and cURL.
We&#8217;ve seen some of these commands before and can reuse previous
command line invocations and variables that we used when generating
our webhook using the API via cURL. Our config variable is similar,
but the required fields in this case are: the title and body for the
pull request, the "head" key which matches the name of the branch, and
where to merge it to using the "base" key.</p>
</div>
<div class="paragraph">
<p>Creating a new branch, adding some content and then issuing a pull
request against the branch might be something we need to do several
(or more) times as we experiment and learn about the Hubot extension
API. The examples here work right out of the box, but don&#8217;t be fooled
into thinking that it all went exactly as we expected the first time.
Given that, these are commands you might want to perform multiple times as you are
experimenting, so let&#8217;s put the commands described in the prior paragraph
into a bash script that is generic and can be run multiple times. We
can call it <code>issue-pull-request.sh</code> and place the script inside the
test directory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Modify these three variables
AUTH_TOKEN=b2ac1f43aeb8d73b69754d2fe337de7035ec9df7
USERNAME=xrd
REPOSITORY=test_repository

DATE=$(date "+%s")
NEW_BRANCH=$DATE
git checkout -b $NEW_BRANCH
echo "Adding some content" &gt;&gt; test-$DATE.txt
git commit -m "Adding test file to test branch at $DATE" -a
git push origin $NEW_BRANCH
CONFIG=$(echo '
{ "title": "PR on '$DATE'",
  "body" : "Pull this PR'$DATE'",
  "head": "'$NEW_BRANCH'",
  "base": "master"
}' )
URL=https://api.github.com/repos/$USERNAME/$REPOSITORY/pulls
curl -H "Authorization: token $AUTH_TOKEN" \
-H "Content-Type: application/json" -X POST -d "$CONFIG" "$URL"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This script generates a unique string based on the current time. It
then creates and checks out a new branch based on that name, adds some
content to a unique file, commits it, pushes it into GitHub, and generates a
pull request using the API. All you will need to do is make a one-time
update to the three variables at the top of the script to match your
information. This script is resilient in that even if your auth token were incorrect (or
had expired) this command will do nothing other than add testing data
to your test repository, so you can experiment safely. Just be sure
to pay attention to whether you see a successful JSON request as shown
below or an error message. And, as we are going to run this script as
a command, make it executable using the <code>chmod</code> command.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s run it and see what happens.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ chmod +x ./issue-pull-request.sh
$ ./issue-pull-request.sh
{
  "url": "https://api.github.com/repos/xrd/testing_repostory/pulls/1",
  "id": 27330198,
  "html_url": "https://github.com/xrd/testing_repostory/pull/1",
  "diff_url": "https://github.com/xrd/testing_repostory/pull/1.diff",
  "patch_url": "https://github.com/xrd/testing_repostory/pull/1.patch",
  "issue_url": "https://api.github.com/repos/xrd/testing_repostory/issues/1",
  "number": 1,
  "state": "open",
  "locked": false,
  "title": "A PR test",
      "open_issues_count": 1,
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>This returns a huge JSON response (abbreviated here), but you can see
the first item is a link to the pull request. For a human readable
link, we should use the link called <code>html_url</code>. Were we to visit this
link, we could merge the pull request from within the GitHub web UI.</p>
</div>
<div class="paragraph">
<p>To see more context on what is happening with this pull request, once
we are looking at this pull request inside of GitHub, we can then navigate to the
settings for our repository, follow the link to "Webhooks and
Services" on the left navigation bar, and we will then find at the
very bottom of the page a list of recent deliveries to our webhook.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hubot-recent-deliveries.png" alt="A list of failed webhook deliveries">
</div>
</div>
<div class="paragraph">
<p>These requests all failed; our Hubot is not correctly configured
to handle real HTTP requests from GitHub. This does show that GitHub is
trying to do something when a pull request is received. We&#8217;ll work on
getting our handler code written and pushed into Heroku, and then
issue another PR.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_pr_notifications_as_post_requests_over_http">Handling PR Notifications as Post Requests over HTTP</h4>
<div class="paragraph">
<p>Let&#8217;s build our HTTP handler when PRs notifications arrive from
GitHub. At first glance, we might take the easy route, adding it
directly into the top level script. But, given the fact that
JavaScript handles events inside of callbacks and the fact that Hubot
extensions only export a single constructor (using the
<code>module.exports</code> syntax) it is easier to create, and more importantly
test, a separate module which we require in our main extension script.</p>
</div>
<div class="paragraph">
<p>We start by writing our tests. We&#8217;ve already created a test which
verifies the call to <code>robot.router.post</code>. Our new functionality will
actually handle the PR notification, so let&#8217;s add a new grouping using
the describe syntax and call it "#pr". The new functionality is
simple: if the Hubot receives the proper parameters (most importantly
that the internal secret matches the secret sent on the request) then
we accept the PR as valid and message our room with further
instructions, namely inviting some user to review this pull
request. Our handler then needs to expose two methods:
<code>prHandler</code> which is where we delegate any information coming from an
HTTP request to the <code>/pr</code> route, and a method where we can configure
the secret, which we call <code>setSecret</code>. Once we have established this
internal signature for our handler library, we can add two simple
tests and then our library.</p>
</div>
<div class="paragraph">
<p>We have two tests: one which handles the correct flow and one which
handles the incorrect flow. In a before block (this happens before
each test) we setup a fake robot, and set the secret on our handler
module. Our faked robot implements the same methods that a real Hubot
robot does (the "messageRoom" and "send" methods), but we create
Jasmine spies to verify these functions are called inside our
implementation code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">describe "#pr", -&gt;
        secret = "ABCDEF"
        robot = undefined
        res = undefined

        beforeEach -&gt;
                robot = {
                        messageRoom: jasmine.createSpy()
                        }
                res = { send: jasmine.createSpy() }
                Handler.setSecret secret

        it "should disallow calls without the secret", (done) -&gt;
                req = {}
                Handler.prHandler( robot, req, res )
                expect( robot.messageRoom ).not.toHaveBeenCalled()
                expect( res.send ).toHaveBeenCalled()
                done()

        it "should allow calls with the secret", (done) -&gt;
                req = { body: { secret: secret } }
                Handler.prHandler( robot, req, res )
                expect( robot.messageRoom ).toHaveBeenCalled()
                expect( res.send ).toHaveBeenCalled()
                done()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, add a file called <code>./lib/handler.coffee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">_SECRET = undefined

exports.prHandler = ( robot, req, res ) -&gt;
        secret = req.body?.secret
        if secret == _SECRET
                console.log "Secret verified, let's notify our channel"
                room = "general"
                robot.messageRoom room, "OMG, GitHub is on my caller-id!?!"
        res.send "OK\n"

exports.setSecret = (secret) -&gt;
        _SECRET = secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the Hubot API does a lot of work for us: it processes
the JSON POST request to the <code>/pr</code> endpoint and provides us with the
parsed parameters inside the body object. We use that to retrieve the
secret from the request. Even if you have used CoffeeScript before,
you may not be familiar with the <code>?.</code> syntax: this just tests to see
if <code>body</code> is defined and if so, has a key named <code>secret</code>. This prevents
us from crashing if the secret is not sent in with the request. If the
secret from the request matches the configured secret, then we message
the room, otherwise we ignore the request. In either case, we need to
respond to the calling server by using the <code>send</code> method (<code>send</code> is
provided by the built in <strong>express</strong> server that Hubot uses to provide
an HTTP server). For debugging purposes we output that the secret
was validated, if it was in fact validated, but otherwise the behavior
of our response to the calling client is the same regardless of
whether they provided a correct secret or not. We don&#8217;t want to
provide an attacker with anything extra if they pass in an incorrect secret.</p>
</div>
<div class="paragraph">
<p>If we run our tests we will see them all pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ node_modules/jasmine-node/bin/jasmine-node \
--coffee spec/pr-delegator.spec.coffee
....

Finished in 0.01 seconds
4 tests, 6 assertions, 0 failures, 0 skipped</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hubot will spawn the HTTP server wherever it runs so we can talk to it
on our local machine (though this will likely be inside a firewall and
inaccessible to GitHub), so we can test it using cURL
locally. Remember that our robot router accepts commands as HTTP POST
requests, so we need to specify a post request (using the <code>--data</code>
switch with cURL).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ ( HUBOT_SLACK_TOKEN=xoxb-3295776784-nZxl1H3nyLsVcgdD29r1PZCq \
./bin/hubot -a slack 2&gt; /dev/null | grep -i secret &amp; )
$ curl --data '' http://localhost:8080/pr
Invalid secret
OK
$ curl --data 'secret=XYZABC' http://localhost:8080/pr
Secret verified
OK
$ kill `ps a | grep node | grep -v grep | awk -F ' ' '{ print $1 }'`</code></pre>
</div>
</div>
<div class="paragraph">
<p>These commands verify that things are working properly. First, we
start the server, piping the output to <code>grep</code> to contrain output
related to our secret processing (we also background the
entire chain using an ampersand and parentheses, a bash trick). Then,
we hit the server running locally without the secret: the server (as
it is running in the same shell) prints out the
message "Invalid secret" using <code>console.log</code>, and then curl prints out
"OK" which is what was returned from our server. If we run the command
again, this time including the secret as post parameters, we see that
Hubot verified the secret internally against its own secret, and then
curl again prints "OK" which was what the express server inside of
Hubot returned to the calling client. The final line quits Hubot:
this command finds the PID for the Hubot client (which runs as a node
process) and then sends it a SIGHUP signal, signaling to Hubot that it
should quit.</p>
</div>
<div class="paragraph">
<p>Provided you connected correctly to your Slack site, you&#8217;ll also see a
message inside your #general channel which says "OMG, GitHub is on my
caller-id!?!" We now have a simple way to trigger a pull request notification
without going through the formality of actually generating a pull
request. Between our script which issues real pull requests through the
GitHub API and this one that fakes a webhook notification, we have the
ability to test our code externally as we develop it. Of course, our
tests are valuable, but sometimes we it is impossible to understand
what is happening inside of our Hubot without running against the
real Hubot and not a test harness.</p>
</div>
<div class="sect4">
<h5 id="_assigning_an_active_chat_room_user">Assigning an active chat room user</h5>
<div class="paragraph">
<p>Now that we have an incoming pull request (albeit one which we are
faking), we need to write the code to find a random user and assign them
to the pull request.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
This next section is redundant; our Hubot will function
exactly as we need it to if you were to disregard any code from this
section. As I was writing this book, I mistakenly missed the fact that
the Hubot <code>brain</code> contains a list of users and found another avenue to
getting that data, the Slack API. I wrote the chapter using the Slack
API, and then discovered my mistake. Initially I planned to remove
this entire section. However, it does demonstrate the ease of using an
external service through the built in HTTP client, which is a powerful
feature of Hubot. And, it also demonstrates how powerful tests aid you
when developing a Hubot extension; I was able to refactor to use a
radically different internal code path for getting the list of users
and maintain faith that the end to end process of my code works by
refactoring and then fixing broken tests. And, though not important
for this section per se, the Slack API provides much richer data on
the users logged into a room, which could be valuable in other
situations. If you want to skip to the next section, you will have all
the code to build our Hubot as we described earlier. But, I think it
is a worthwhile read for general Hubot understanding.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To find a user in the room, one option is to go
outside the Hubot API and use the Slack.com API to query for a list of
users. The Slack.com API provides an endpoint giving you all
users currently in a room. To access the Slack.com API, we will
use the built in Hubot HTTP client. Once we have the the
list of members in the room we can look over this list
and randomly choose a member and deliver the PR request to them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">_SECRET = undefined

anyoneButProbot = (members) -&gt;  <b class="conum">(1)</b>
        user = undefined
        while not user
                user = members[ parseInt( Math.random() * members.length ) ].name
                user = undefined if "probot" == user
        user

sendPrRequest = ( robot, body, room, url ) -&gt; <b class="conum">(2)</b>
        parsed = JSON.parse( body )
        user = anyoneButProbot( parsed.members )
        robot.messageRoom room, "#{user}: Hey, want a PR? #{url}"

exports.prHandler = ( robot, req, res ) -&gt;
        slack_users_url =   <b class="conum">(3)</b>
                "https://slack.com/api/users.list?token=" +
                process.env.HUBOT_SLACK_TOKEN
        secret = req.body?.secret <b class="conum">(4)</b>
        url = req.body?.url

        if secret == _SECRET and url
                room = "general"
                robot.http( slack_users_url ) <b class="conum">(5)</b>
                        .get() (err, response, body) -&gt;
                                sendPrRequest( robot, body, room, url ) unless err
        else
                console.log "Invalid secret or no URL specified"
        res.send "OK\n"

exports.setSecret = (secret) -&gt;
        _SECRET = secret</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We define a method called <code>anyoneButProbot</code> that takes a list of
users and finds a random one, as long as it is not the hubot.</p>
</li>
<li>
<p>The <code>sendPrRequest</code> method parses the JSON returned from the Slack
API and then sends the members inside of the object into the
<code>anyoneButProbot</code> call. It then uses the Hubot API to send a message
to the room asking if that user will accept the pull request review
invitation.</p>
</li>
<li>
<p>We build the URL to the Slack service by tacking on the Slack API
token to the base Slack API URL.</p>
</li>
<li>
<p>As we did before, we pull out the secret and the PR URL, and then
make sure they both exist.</p>
</li>
<li>
<p>We use the built in HTTP client to make a GET request to the
Slack API. Unless we receive an error in the response callback, we
use the data provided by the Slack API to initiate the PR review
request.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To test this using our cURL command, we need to modify the invocation
slightly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ curl --data 'secret=XYZABC&amp;url=http://pr/1' \
http://localhost:8080/pr</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our randomly selected user will see the text <code>username: Hey, want a
PR? <a href="http://pr/1" class="bare">http://pr/1</a></code> (and the Slack client will format that link as a
clickable URL).</p>
</div>
<div class="paragraph">
<p>Unfortunately, our tests are now broken: we now have the failure: <code>TypeError:
Object #&lt;Object&gt; has no method 'http'</code>. Our mocked Robot object that
we pass into our tests does not have the http interface that comes
with Hubot, so we should add it to our custom Robot. The method
signature for the  http client (which comes from the
<code>node-scoped-http-client</code> NodeJS package) is hairy: you chain calls
together to build up an HTTP client request and end up with a function
returned into which you pass a callback where you handle the response
body. This module makes you write code that is not particularly
testable (said another way, it was challenging for me to understand
what the faked test implementation should look like) but the setup
code does work and the tests itself document an interface to our robot
which is easily understandable. We simulate the
same chain, defining a <code>http</code> attribute on the mocked robot object, an
attribute which resolves to a function call itself. Calling that function
returns an object which has a <code>get</code> method, and calling that function
returns a function callback which when called executes that function
with three parameters. In real life that function callback would
contain the error code, the response object, and the JSON. In our
case, as long as the error code is empty, our implementation will
parse the JSON for members, and then issue the PR request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">json = '{ "members" : [ { "name" : "bar" } , { "name" : "foo" } ] }'

httpSpy = jasmine.createSpy( 'http' ).and.returnValue(
        { get: () -&gt; ( func ) -&gt;
                func( undefined, undefined, json ) } )

beforeEach -&gt;
        robot = {
                messageRoom: jasmine.createSpy( 'messageRoom' )
                http: httpSpy
                }

        res = { send: jasmine.createSpy( 'send' ) }
        Handler.setSecret secret

it "should disallow calls without the secret", (done) -&gt;
        req = {}
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).not.toHaveBeenCalled()
        expect( httpSpy ).not.toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()

it "should disallow calls without the url", (done) -&gt;
        req = { body: { secret: secret } }
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).not.toHaveBeenCalled()
        expect( httpSpy ).not.toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()

it "should allow calls with the secret", (done) -&gt;
        req = { body: { secret: secret, url: "http://pr/1" } }
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).toHaveBeenCalled()
        expect( httpSpy ).toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code we write here was definitely not a piece of code where
testing came easy; I refactored this multiple times to find a balance
between an easy to read test and easy to read code. Writing test code
takes effort, but when both your tests and code are readable and
minimal, you generally can be sure you have a good implementation.</p>
</div>
<div class="paragraph">
<p>We now have a functional and complete implementation of the code to
retrieve a list of users and assign an incoming pull request out to a
randomly selected user from that list.</p>
</div>
</div>
<div class="sect4">
<h5 id="_the_user_list_from_the_hubot_brain">The User List from the Hubot Brain</h5>
<div class="paragraph">
<p>Instead of using the Slack API, we can replace the code with a
much simpler call to <code>robot.brain.users</code>. Calling into the Slack users
API takes a callback, but the <code>brain.users</code> call does not, which
simplifies our code. We do verify inside our tests that we make a call to
the HTTP Jasmine spy on the <code>get</code> function, so we will want to remove
that inside our tests. We will need to provide a new function called
<code>users</code> to the Hubot inside the faked brain we created</p>
</div>
<div class="paragraph">
<p>Unfortunately, things don&#8217;t just work when we change our code to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
users = robot.brain.users()
sendPrRequest( robot, users, room, url, number )
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is likely that what we got back from the Slack API and what Hubot
stores inside its brain for users are functionally the same
information, but structural stored very differently. How can we
investigate whether this assumption is correct?
NodeJS has a standard library module called <code>util</code> which includes
useful utility functions, as you might expect from the name.
One of them is <code>inspect</code> which will dig into an object and
create a pretty printed view. If we use this module and <code>console.log</code>
we can see the full contents of a live response object passed into our
<code>accept</code> function. A line like the following <code>console.log( require(
'util' ).inspect( users ) )</code> displays the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{ U04FVFE97:
   { id: 'U04FVFE97',
     name: 'ben',
     real_name: 'Ben Straub',
     email_address: 'xxx' },
  U038PNUP2:
   { id: 'U038PNUP2',
     name: 'probot',
     real_name: '',
     email_address: undefined },
  U04624M1A:
   { id: 'U04624M1A',
     name: 'teddyhyde',
     real_name: 'Teddy Hyde',
     email_address: 'xxx' },
  U030YMBJY:
   { id: 'U030YMBJY',
     name: 'xrd',
     real_name: 'Chris Dawson',
     email_address: 'xxx' },
  USLACKBOT:
   { id: 'USLACKBOT',
     name: 'slackbot',
     real_name: 'Slack Bot',
     email_address: null } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ah, we were right: the Slack API returns an array while this is an
associate array (called a hash in other languages). So, we need to
refactor our inputs to the test to take an associative array instead
of an array, and then we need a function to flatten it
out (after that our code will work the same as before). We will return
that when the user calls <code>robot.brain.users</code> so add a new spy as the
<code>users</code> key inside our fake robot.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
users = { CDAWSON: { name: "Chris Dawson" }, BSTRAUB: { name: "Ben Straub" } }
brainSpy = {
        users: jasmine.createSpy( 'getUsers' ).and.returnValue( users ),
        set: jasmine.createSpy( 'setBrain' ),
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inside our implementation code, flatten out the user associative array
and find the user inside the new flattened array.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
flattenUsers = (users) -&gt;
        rv = []
        for x in Object.keys( users )
               rv.push users[x]
        rv

anyoneButProbot = ( users ) -&gt;
        user = undefined
        flattened = flattenUsers( users )
        while not user
                user = flattened[ parseInt( Math.random() * flattened.length ) ].name
                user = undefined if "probot" == user
        user

...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_sending_pr_data_via_webhook">Sending PR Data via Webhook</h5>
<div class="paragraph">
<p>Our wiring is almost complete, so let&#8217;s actually send real pull
request information. If we run our script <code>issue-pull-request.sh</code> we
will see it sending data out to our Hubot. Once we have deployed to
Heroku, our Hubot is listening on a public hostname. GitHub will
accept the pull request and then send a JSON inside the body of a POST
request made to our Hubot. This JSON looks very different from the
url encoded parameters we provide in our cURL script, so we need to
modify our code to fit.</p>
</div>
<div class="paragraph">
<p>If we retrieve the JSON from a POST, it will look something like this
(reformatted for clarity and brevity):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "action":"opened",
    "number":13,
    "pull_request": {
      "locked" : false,
      "comments_url" :
      "https://api.github.com/repos/xrd/test_repository/issues/13/comments",
      "url" : "https://api.github.com/repos/xrd/test_repository/pulls/13",
      "html_url" : "https://github.com/xrd/test_repository/pulls/13",
      }
      ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most importantly, you see a URL (the <code>html_url</code> more specifically) which we will use inside our Hubot
message to the user. Retrieving the json and parsing it is trivial
inside our Hubot.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
exports.prHandler = ( robot, req, res ) -&gt;
        body = req.body
        pr = JSON.parse body if body
        url = pr.pull_request.html_url if pr
        secret = pr.secret if pr

        if secret == _SECRET and url
                room = "general"
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here you see we pull out the body contents, process them as JSON,
extract the secret and the URL from the parsed JSON, and then go
through our normal routine.</p>
</div>
<div class="paragraph">
<p>Our tests are simple, and require that we send in JSON.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
it "should disallow calls without the secret and url", (done) -&gt;
        req = {}
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).not.toHaveBeenCalled()
        expect( httpSpy ).not.toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
       done()

it "should allow calls with the secret and url", (done) -&gt;
        req = { body: '{ "pull_request" : { "html_url" : "http://pr/1" },
        "secret": "ABCDEF" }' }
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).toHaveBeenCalled()
        expect( httpSpy ).toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We are putting the secret inside the JSON as a convenience. The secret
will not come in with the JSON when GitHub sends us JSON via the
webhook, but this is an easy way to provide it to our handler for the
moment. If we run our tests, they should pass now.</p>
</div>
</div>
<div class="sect4">
<h5 id="_securing_the_webhook">Securing the Webhook</h5>
<div class="paragraph">
<p>Our Hubot is now in a position where it will operate correctly if the
secret passes validation and the webhook data is passed properly. Now
we need to secure the webhook. GitHub signs your data inside the
webhook payload which provides you with a way to verify the data
really came from an authorized host. We need to decode it inside our
handler. To do this, we will need to retrieve the secure hash GitHub
provides inside the request headers. Then, we will need to calculate
the hash ourselves using the secret we maintain internally. If these
hashes match, then we know the incoming request and JSON is truly from
GitHub and not an attacker.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
getSecureHash = (body, secret) -&gt;
        hash = crypto.
                createHmac( 'sha1', secret ).
                update( "sha1=" + body ).
                digest('hex')
        console.log "Hash: #{hash}"
        hash

exports.prHandler = ( robot, req, res ) -&gt;
        slack_users_url =
                "https://slack.com/api/users.list?token=" +
                process.env.HUBOT_SLACK_TOKEN
        body = req.body
        pr = JSON.parse body if body
        url = pr.pull_request.html_url if pr
        secureHash = getSecureHash( body, _SECRET ) if body
        webhookProvidedHash = req.headers['HTTP_X_HUB_SIGNATURE' ] if req?.headers
        secureCompare = require 'secure-compare'

        if secureCompare( secureHash, webhookProvidedHash ) and url
                room = "general"
                robot.http( slack_users_url ) -&gt;
                        .get() (err, response, body) -&gt;
                                sendPrRequest( robot, body, room, url ) unless err
        else
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The signature is a "hash message authentication code" (HMAC). HMAC
cryptography is vulnerable to timing attacks. When you use this
encryption technique, the time it takes to complete a comparison of
the computed hash and the sent hash can be the starting point for an attacker to gain
forced access to a server. More specifically to JavaScript, naive
comparison operators like <code>==</code> will leak this timing information.
To eliminate the risk that this information could be used to
compromise the host system, we use a module called <code>secure-compare</code>
that obscures this timing information when making a comparison. To
load this module, we need to add it to our package.json manifest file
with the command <code>npm install secure-compare --save</code>.</p>
</div>
<div class="paragraph">
<p>Now we can adjust our tests to fit the new reality of our handler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
it "should disallow calls without the secret and url", (done) -&gt;
        req = {}
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).not.toHaveBeenCalled()
        expect( httpSpy ).not.toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()

it "should allow calls with the secret and url", (done) -&gt;
        req = { body: '{ "pull_request" : { "html_url" : "http://pr/1" }}',
  		headers: { "HTTP_X_HUB_SIGNATURE" :
		           "cd970490d83c01b678fa9af55f3c7854b5d22918" } }
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).toHaveBeenCalled()
        expect( httpSpy ).toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll notice we moved the secret out of the JSON and into the
headers. This is the same structure our Hubot will see when the
GitHub webhook encodes the content of the JSON and provides us with a
secure hash in the HTTP_X_HUB_SIGNATURE key. Inside our test we will need
to provide the same signature inside our mocked request object. We
could duplicate our secure hash generation code from the
handler implementation, or we could be lazy and just run our tests
once (knowing they will fail this time), watch for the
console.log output which says "Hash: cd970490d83c&#8230;&#8203;" and copy this
hash into our mocked request object. Once we do this, our tests will
pass.</p>
</div>
<div class="paragraph">
<p>Now, after reloading our Hubot, if we issue a pull request using our
<code>issue-pull-request.sh</code> script, we should see the matching
hashes. But, we won&#8217;t (at least if you used the same <code>package.json</code>
file as we specified above) because of a critical bug inside of Hubot
at the time of this writing.</p>
</div>
<div class="paragraph">
<p>As we mentioned earlier, Hubot bundles Express.js, a high performance
web framework for NodeJS. Express.js has a modular architecture, where
middleware is inserted into a request and response chain. This
approach to building functionality and the wide array of middleware
allows web developers to string together various standardized
middleware components to use only those features needed for the
problem at hand. Common middleware includes static file handlers (for
serving static files), cookie handlers, session handlers, and body
parsers. You can imagine circumstances where you would not need all of
the list above (or you might need others) and this flexibility makes
Express.js a popular choice for building NodeJS web applications.</p>
</div>
<div class="paragraph">
<p>The body parser middleware is of particular interest to us here: the
body parser middleware is used to convert the "body" of a request into
a JavaScript object attached to the request object. Above you saw us
access it inside a variable we called <code>req</code> inside our callback;
obviously this stands for request. The body parser takes on converting
whatever data content comes from inside the body of the HTTP request into a
structured JavaScript associative array inside the <code>body</code> object within our
request object. If the body is url encoded (as the PR information is
encoded if we create the webhook with the <code>content_type</code> set to
<code>form</code>), then the body parser url decodes the content, parses it as
JSON, and then sets the inflated object to the body attribute on our
request object. Normally, this is a very handy process that removes a
lot of grunt work for web application authors.</p>
</div>
<div class="paragraph">
<p>Unfortunately, because the <code>express</code> object is bundled and configured for us long
before our extension is loaded, we cannot interrupt the load order of
the body parser middleware inside our extension and this means we
cannot get access to the raw body content. The body parser middleware
processes the stream of
data by registering for events inside of the HTTP request flow. NodeJS
made a mark on web application development by providing a network
application toolkit centered around one of the
most controversial features of JavaScript: the asynchronous
callback. In NodeJS, processes register for events and then return
control to the host program. In other languages, like Ruby for
example, when building services which receive data from clients, by
default, you listen for incoming data, and the moment you tell your
program to listen, you have blocked other processing. Asynchronous
programming is by no means a new concept (threading in many languages,
for example), but NodeJS offers a simple way to interact with
asynchronous functions through event registration. In the case of
express middleware, however, this event registration process bites us,
because middleware loaded first gets first access to incoming data,
and once the body parser has processed our body content, we no longer
can access the original content. We need access to the raw body
content, and there is no way to install our own middleware which would
provide it inside our Hubot extension when a PR request is received
on the router.</p>
</div>
<div class="paragraph">
<p>What options do we have then? Well, fortunately, every bit of our
stack here is open source, and we can modify the code inside Hubot
which sets up our express server to fit our needs. This code is
installed by the <code>npm</code> tool into the <code>node_modules</code> directory and we
can easily find where express is configured inside of Hubot. There are
issues with doing it this way: if we re-run <code>npm install</code> we will blow
away our <code>node_modules</code> directory, and this is something Heroku will
do if it is not told otherwise. A better way might be to fork Hubot
and store our own copy of Hubot inside of GitHub and then specify our
forked copy inside of the <code>package.json</code> file. This has issues too; if
Hubot gets updated with a critical security flaw, we need to merge
those changes into our fork, a maintenance issue which we would avoid
if we use tagged releases from the main repository. There is,
unfortunately, no perfect way to resolve this problem that does not
itself create other problems.</p>
</div>
<div class="paragraph">
<p>If you do choose to modify the built in hubot code, modify the file
<code>robot.coffee</code> inside the <code>node_modules/hubot/src/</code> directory. The
node_modules directory, in case memory fails, is where the NodeJS
package manager (npm) builds out the local dependency tree for
libraries, and this is the file Hubot uses internally to build the
robot object and setup the express HTTP server. If we add the
following code at line 288 (this line number might vary if you are not
using the same version of Hubot we specify in our package.json), we
can install a custom middleware callback which will provide us with
the raw body which we can use when verifying the HMAC signature.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
app.use (req, res, next) =&gt;
  res.setHeader "X-Powered-By", "hubot/#{@name}"
  next()

app.use (req, res, next) =&gt;
  req.rawBody = ''
  req.on 'data', (chunk) -&gt;
    req.rawBody += chunk
  next()

app.use express.basicAuth user, pass if user and pass
app.use express.query()

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Express middleware have a very simple interface: they are nothing more
than a JavaScript function callback which receives a request, response
and continuation function passed as parameters. We
register a listener when data content (the body) is propagated, and
then add the body content to a variable on the request object. When
the request object is passed into our handler for pull requests within
our Hubot, we have the raw data prefilled. The <code>next()</code> function is
used to indicate to the middleware host that the next middleware can
proceed.</p>
</div>
<div class="paragraph">
<p>We now need to adjust our tests to fit this new requirement. We prime
the pump with a request object that has this <code>rawBody</code> inside
it, and we should properly encode the content using
<code>encodeURIComponent</code> to match the format in which it will be appearing
from GitHub.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
it "should allow calls with the secret and url", (done) -&gt;
        payload =  '{ "pull_request" : { "html_url" : "http://pr/1" } }'
        bodyPayload = "payload=#{encodeURIComponent(payload)}"
        req = { rawBody: bodyPayload,
        headers: { "x-hub-signature" : "sha1=dc827de09c5b57da3ee54dcfc8c5d09a3d3e6109" } }

        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).toHaveBeenCalled()
        expect( httpSpy ).toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our implementation breaks our tests, so we will need to modify the
cost to use the <code>rawBody</code> attribute on the request object, break it
apart from the payload key-value pair, URI decode it, and then if all
that works, parse the JSON and start the verification process. Our
tests describe all this for us. The new <code>prHandler</code> method looks like
this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
exports.prHandler = ( robot, req, res ) -&gt;

        rawBody = req.rawBody
        body = rawBody.split( '=' ) if rawBody
        payloadData = body[1] if body and body.length == 2
        if payloadData
                decodedJson = decodeURIComponent payloadData
                pr = JSON.parse decodedJson

                if pr and pr.pull_request
                        url = pr.pull_request.html_url
                        secureHash = getSecureHash( rawBody )
                        signatureKey = "x-hub-signature"
                        if req?.headers
                                webhookProvidedHash =
                                        req.headers[ signatureKey ]
                        secureCompare = require 'secure-compare'
                        if url and secureCompare( "sha1=#{secureHash}",
                                        webhookProvidedHash )
                                room = "general"
                                users = robot.brain.users()
                                sendPrRequest( robot, users, room, url )
                        else
                                console.log "Invalid secret or no URL specified"
                else
                        console.log "No pull request in here"

        res.send "OK\n"

_GITHUB = undefined

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>When all is said and done, is verifying the signature even worth it?
If we are not hosting our Hubot on a service which handles our router
requests over HTTPS, this HMAC verification could be compromised. And,
given the issues with maintaining our own copy of the Hubot code in
order to permit the validation inside our Hubot extension, it might be
best to ignore the validation header. The worst case, as our extension
is written now, would be that an attacker could fake a pull request
notification, and falsely engage chat room users around it. If the PR
the attacker used was fake, it might confuse our Hubot, but no real
harm would be done. If they used an existing real PR, an attacker
could trick our Hubot into adding data to the PR, adding confusion in
the comments about who accepted the review request. We won&#8217;t solve that
potential problem with this code, but you can imagine adding code to
our Hubot that handles a case like this (for example, by checking
first to see if someone was already tagged on the PR, and ignoring
successive incoming webhooks associated with that PR).</p>
</div>
</div>
<div class="sect4">
<h5 id="_responding_to_the_pr_request">Responding to the PR Request</h5>
<div class="paragraph">
<p>Our Hubot is now programmed to generate a pull request review message and
send it to a random user. What happens when they respond? They can
respond in two ways obviously: accepting the request or declining the
request. We put placeholders in our Hubot extension to notify us with
a debugging message when the user responds and send a message back to
whoever sent us a message, but now we can actually wire up handling
the response and adding to the pull request on GitHub based on the
user who we are interacting with (provided they accepted).</p>
</div>
<div class="paragraph">
<p>There are multiple ways in which a Hubot can interact with chat room
messages. We chose the <code>respond</code> method, but there is another method
<code>hear</code> which we could have used. <code>respond</code> is used when the message
is preceeded by the Hubot name, so only messages that look like
<code>probot: accept</code> or <code>@probot decline</code> or <code>/ accept</code> (if the Hubot name alias is
enabled) will be processed by our Hubot. We could have used <code>hear</code>
but in our case we are processing a simple response, and
without a clear direction for the message, it would be difficult to
always make sure we were interpreting the message in the correct
context. <code>respond</code> makes more sense here.</p>
</div>
<div class="paragraph">
<p>If they decline the request, let&#8217;s just graciously note that the offer
was declined.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
exports.decline = ( res ) -&gt;
        res.reply "No problem, we'll go through this PR in a bug scrub"

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We are asking someone to accept a pull request and there is a possible
situation where two could come in within a very short period of
time. For this reason, it probably makes sense for us to indicate the
pull request identifier in the communication with the target
user. And, users should be told to reply with a string like <code>accept
112</code>. The Hubot can then interpret this to mean they are accepting PR
#112 and not the other pull request which the hubot invited John to
respond to ten seconds later.</p>
</div>
<div class="paragraph">
<p>If we do this, our hubot does need to save the state of pull request
invitations. Fortunately, there is an extremely easy way to do this
using the "brain" of our hubot. The brain is a persistent store,
typically backed by Redis, into which you can keep any type of
information. You simply reference the <code>robot.brain</code> and use methods
like <code>get</code> or <code>set</code> to retrieve and store information. The <code>set</code>
method takes any key and any value but note that the Hubot brain does
not do much with your value if that value happens to be a complex
object; if you want to properly serialize something beyond a flat
value, you should probably call <code>JSON.stringify</code> on the object to
maintain full control over the roundtrip storing and retrieval.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s modify our Hubot handler to deal with accepting or declining
responses (and change our extension file to deal with this new
interface). Of course, we will need to add to our tests. Finally, we
will need to set up a way to provide the GitHub API key to our Hubot
handler, so we&#8217;ll add a method to do that that looks almost exactly
like the one for setting our secret key.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll use a GitHub API NodeJs module called <code>node-github</code>, found on
GitHub at <a href="https://github.com/mikedeboer/node-github" class="bare">https://github.com/mikedeboer/node-github</a>. If we look
at the API documentation, we see that it supports authentication using
an oAuth token (using the <code>github.authenticate( {  'type' : 'oauth':
'token' : '&#8230;&#8203;' }</code> syntax), and has methods we can use to add a comment to an
issue or pull request associated with a repository (using the
<code>github.issues.createComment</code> method).</p>
</div>
<div class="paragraph">
<p>Knowing that this module handles most of the work for us between these
two methods, we can start by writing our tests. We&#8217;ll create a new
describe block called <code>#response</code> which groups our tests together. As
we noted above, our Hubot can take affirmative and negative
responses, so our tests should reflect these two code paths. Our setup
block (the <code>beforeEach</code> section) in both cases should do the same
thing for each response, make the pull request invitation to a random user: this all
happens inside our <code>prHandler</code> code. We don&#8217;t need to verify the
expectations of this method since that got that covered by prior
tests. After we get our handler to the right state, we need to test
that the handler works correctly with an <code>accept</code> and <code>decline</code> method
(they don&#8217;t yet exist in our handler code so we&#8217;ll add them
next).</p>
</div>
<div class="paragraph">
<p>Our accept request handler triggers our Hubot to
contact GitHub and add a comment to the pull request noting
our targetted chat user accepted the request. The network
connection to the GitHub API uses the GitHub API bindings from within
the <code>node-github</code> module. We want to make this testable, so we should pass in the
GitHub binding object inside our interface, and during the test, pass
in a mocked object. If we review the documentation for the
<code>createComment</code> in the GitHub API binding, we see it requires
information about the repository such as the user or organization
which owns the repository, the repository name, the issue number (pull
requests also are referenced by issue numbers) and the comment
itself. To get this information we simply need to decode it from the
Hubot handler which receives the pull request information, and we
will add code which does this (and is exposed in our handler for
testing). We saw that a pull request comes in through a large JSON
response, and we can use the URL we used earlier as the way we decode
this information. So, we&#8217;ll need to have two more tests inside our
<code>#response</code> block, one for the decoding of the URL into a message
object, and another to retrieve the username which we insert into the
comment stored in the pull request on the repository. We know what our
test URL looks like since we saw it in our PR webhook message, but we
don&#8217;t yet have the structure of the chat message from which we can
pull out our username, so our test will need to be adjusted when we
know what it really looks like.</p>
</div>
<div class="paragraph">
<p>Declining the request means nothing happens. If we
mock out our GitHub API binding, acceptance should login (using the
<code>authenticate</code> method) and then call <code>createComment</code>. These are
directly pulled from the GitHub API NodeJS documentation. Finally, we
should record the result of this operation inside the chat room which
happens using the reply method on our response object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
                describe "#response", -&gt;
                        createComment = jasmine.createSpy( 'createComment' ).and.
                                callFake( ( msg, cb ) -&gt; cb( false, "some data" ) )
                        issues = { createComment: createComment }
                        authenticate = jasmine.createSpy( 'ghAuthenticate' )
                        responder = { reply: jasmine.createSpy( 'reply' ),
                        send: jasmine.createSpy( 'send' ) }

                        beforeEach -&gt;
                                githubBinding = { authenticate: authenticate, issues: issues }
                                github = Handler.setApiToken( githubBinding, "ABCDEF" )
                                req = { body: '{ "pull_request" : { "url" : "http://pr/1" }}',
				      	headers: { "HTTP_X_HUB_SIGNATURE" :
"cd970490d83c01b678fa9af55f3c7854b5d22918" } }
                                Handler.prHandler( robot, req, responder )

                        it "should tag the PR on GitHub if the user accepts", (done) -&gt;
                                Handler.accept( responder )
                                expect( authenticate ).toHaveBeenCalled()
                                expect( createComment ).toHaveBeenCalled()
                                expect( responder.reply ).toHaveBeenCalled()
                                done()

                        it "should not tag the PR on GitHub if the user declines", (done) -&gt;
                                Handler.decline( responder )
                                expect( authenticate ).toHaveBeenCalled()
                                expect( createComment ).not.toHaveBeenCalledWith()
                                expect( responder.reply ).toHaveBeenCalled()
                                done()

                        it "should decode the URL into a proper message object for the createMessage call", (done) -&gt;
                                url = "https://github.com/xrd/testing_repository/pull/1"
                                msg = Handler.decodePullRequest( url )
                                expect( msg.user ).toEqual( "xrd" )
                                expect( msg.repository ).toEqual( "testing_repository" )
                                expect( msg.number ).toEqual( "1" )
                                done()

                        it "should get the username from the response object", (done) -&gt;
                                res = { username: { name: "Chris Dawson" } }
                                expect( Handler.getUsernameFromResponse( res ) ).toEqual "Chris Dawson"
                                done()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our tests will fail if we run them now. So, let&#8217;s write the code at
the end of our delegator extension. We need code which parses the URL into the
appropriate structured message object, code to put the reminder into
the pull request comment on GitHub and code which pulls the user out
of the response object passed to us. The first two of these are within
reach; basic JavaScript and reading the GitHub API
binding documentation will get us to these two. The third one requires a
little more investigation, so we will leave this as a placeholder for now.</p>
</div>
<div class="paragraph">
<p>To convert the URL into the object necessary for the <code>createMessage</code>
call, we just need to split the message into pieces by the slash
character, and then retrieve the correct items by index. We probably
could add some additional tests which cover passing in empty strings,
or other edge cases, but we&#8217;ll leave it as an exercise to the
reader. Our code does not crash in these cases, but it would be
nice to have coverage of our expectations represented in our tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
_GITHUB = undefined
_PR_URL = undefined

exports.decodePullRequest = (url) -&gt;
        rv = {}
        if url
                chunks = url.split "/"
                if chunks.length == 7
                        rv.user = chunks[3]
                        rv.repository = chunks[4]
                        rv.number = chunks[6]
        rv

exports.getUsernameFromResponse = ( res ) -&gt;
        "username"

exports.accept = ( res ) -&gt;

        msg = exports.decodePullRequest( _PR_URL )
        username = exports.getUsernameFromResponse( res )
        msg.body = "@#{username} will review this (via Probot)."

        _GITHUB.issues.createComment msg, ( err, data ) -&gt;
                unless err
                        res.reply "Thanks, I've noted that in a PR comment!"
                else
                        res.reply "Something went wrong, I could not tag you on the PR comment"

exports.decline = ( res ) -&gt;
        res.reply "OK, I'll find someone else."
        console.log "Declined!"

exports.setApiToken = (github, token) -&gt;
        _API_TOKEN = token
        _GITHUB = github
        _GITHUB.authenticate type: "oauth", token: token

exports.setSecret = (secret) -&gt;
        _SECRET = secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>To summarize, we added an internal variable called <code>_GITHUB</code> where we will store a
reference to our instantiation of the GitHub API binding. Our
interface to the <code>setApiToken</code> call passes in the instantiation; this
method takes our oAuth token and the binding because using an
interface like this means we can pass in a mocked binding inside our
tests. When we are not running inside a test, this method call
authenticates against the GitHub API, readying the API binding to make
connections to the GitHub API itself.</p>
</div>
<div class="paragraph">
<p>Our top level extension script looks like this now.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">handler = require '../lib/handler'

handler.setSecret "XYZABC"
github = require 'node-github'
handler.setApiToken github, "12345ABCDEF"

module.exports = (robot) -&gt;
        robot.respond /accept/i, ( res ) -&gt;
                handler.accept( res )

        robot.respond /decline/i, ( res ) -&gt;
                handler.decline( res )

        robot.router.post '/pr', ( req, res ) -&gt;
                handler.prHandler( robot, req, res )</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you were to look only at this code, the interface is clean, and the
bulk of the work handled by our very testable handler.</p>
</div>
</div>
<div class="sect4">
<h5 id="_peering_into_the_response_object">Peering into the Response object</h5>
<div class="paragraph">
<p>We need to get the username and it stands to reason the object passed
to us when we get a respond callback might have it in there. The
<code>respond</code> method provided by the Hubot API is documented mostly by
way of the example scripts which come with hubot. There is very little
information on what the parameter passed to your callback looks
like. Let&#8217;s use the <code>util</code> library to inspect the data and print it to
the console. We abbreviate the full output here, and show you that it
contains information on the  user who sent the message to our
Hubot. We can access this information by using
<code>response.message.user.name</code> if, for example, we wanted to retrieve
the name of the user.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{ robot:
   { name: 'probot',
     brain:
      { data: [Object],
  ...
  message:
   { user:
      { id: '...',
        name: 'xrd',
        real_name: 'Chris Dawson',
        email: 'chrisdawson@example.com'
     ...
     text: 'probot accept',
     rawText: 'accept',
     rawMessage:
      { _client: [Object],
  ...
  match: [ 'probot accept', index: 0, input: 'probot accept' ],
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inside it all we can find information we need,
specifically the user name and email. So, let&#8217;s update our test and
our handler code. The last test in our spec file can be modified to
look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
it "should get the username from the response object", (done) -&gt;
        res = { message: { user: { name: "Chris Dawson" } } }
        expect( Handler.getUsernameFromResponse( res ) ).toEqual "Chris Dawson"
        done()

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>And, our handler code defining <code>getUsernameFromResponse</code> simply turns into this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
exports.getUsernameFromResponse = ( res ) -&gt;
        res.message.user.name

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this information in hand, we can properly comment on the pull
request. Well, almost.</p>
</div>
</div>
<div class="sect4">
<h5 id="_unifying_usernames_via_the_collaborators_api">Unifying Usernames via the Collaborators API</h5>
<div class="paragraph">
<p>If the Slack username for the person who accepted the pull request is an
exact match with their GitHub username, then we can assume they are
the same person in real life and create a comment inside the pull
request reminding them (and anyone else) that they will be reviewing
the PR. We can use the collaborator sub section of the Repository API
to look up their name on GitHub.</p>
</div>
<div class="paragraph">
<p>If we don&#8217;t find them inside the list of users and there is not an
exact match with their Slack name then we have at least one problem,
maybe two. First, we could just have a mismatch in their identities
(their usernames are different on each site). If this is the case, we
could ask them to clarify this inside the slack room. We do have
another case: the user is not a collaborator on the repository hosted
on GitHub. If
this is the case, clarifying their username is not going to help. The
Repository API does support adding a user to the list of collaborators
so we could do that here, but this arguably is a moment where a larger
discussion should happen (write access to a repository is a big
resposibility in a way that being inside a chat room is not). Adding a
user as a repository collaborator should not be automated inside a chat
room. Because of the complexity here, we will write code to unify a
username inside the chat room, but we won&#8217;t handle the case where
there is no clarification to be made because they are not in the
repository collaborator list.</p>
</div>
<div class="paragraph">
<p>Using the GitHub API binding we passed into our <code>setApiToken</code>
call we will verify the user exists as a collaborator on the
repository. The API binding provides a method called <code>getCollaborator</code>
inside the <code>repos</code> namespace which we can use to verify that a
username is on the list of collaborators. It takes as the first
parameter a  message which is used to specify the repository and
owner, and then an attribute called <code>collabuser</code> which is the name you
want to verify is a collaborator. The second parameter to the function
is a callback that is executed once the request has completed. If the
callback returns without an error code, then our Hubot should tag the
pull request with a comment confirming and message the room.</p>
</div>
<div class="paragraph">
<p>Our new test reflects usage of the <code>repos.getCollaborator</code> call. In
our test setup block we mock out the call to <code>getCollaborator</code>
and using Jasmine to "spy on" it so we can assure it was called later
in our actual test.  Our setup is more beefy than before, but we are
following the same patterns of generating spies to watch methods, and
implementing our fake callbacks when necessary. We also can move our
message inside the response object into the one created in our setup
block so that we can use it inside all of our sub-tests, rather than
creating a new object for each test inside the test body.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
send: jasmine.createSpy( 'send' ),
message: { user: { name: "Chris Dawson" } } }
getCollaborator = jasmine.createSpy( 'getCollaborator' ).and.
        callFake( ( msg, cb ) -&gt; cb( false, true ) )
repos = { getCollaborator: getCollaborator }

...

it "should tag the PR on GitHub if the user accepts", (done) -&gt;
        Handler.accept( robot, responder )
        expect( authenticate ).toHaveBeenCalled()
        expect( createComment ).toHaveBeenCalled()
        expect( responder.reply ).toHaveBeenCalled()
        expect( repos.getCollaborator ).toHaveBeenCalled()
        done()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our handler then can implement the accept and decline methods in full.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
exports.accept = ( robot, res ) -&gt;

        prNumber = res.match[1]
        url = robot.brain.get( prNumber )

        msg = exports.decodePullRequest( url )
        username = exports.getUsernameFromResponse( res )
        msg.collabuser = username

        _GITHUB.repos.getCollaborator msg, ( err, collaborator ) -&gt;
                msg.body = "@#{username} will review this (via Probot)."

                _GITHUB.issues.createComment msg, ( err, data ) -&gt;
                        unless err
                                res.reply "Thanks, I've noted that in a PR comment. " +
					  "Review the PR here: #{url}"
                        else
                                res.reply "Something went wrong."  +
					  "I could not tag you on the PR comment: " +
					  "#{require('util').inspect( err )}"

exports.decline = ( res ) -&gt;
        res.reply "No problem, we'll go through this PR in a bug scrub"
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We now have a full implementation of both the <code>accept</code> and <code>decline</code>
methods inside our Hubot.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sanitizing_our_source_code">Sanitizing our source code</h5>
<div class="paragraph">
<p>It is typically bad form to save passwords (or other access
credentials, like oAuth tokens or secrets) inside of source
code. Right now we have hard coded them into our application inside of
the <code>pr-delegator.coffee</code> file. We could instead retrieve them from
the environment of the running process.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-coffeescript" data-lang="coffeescript">...
handler.setSecret process.env.PROBOT_SECRET
github = require 'github'
ginst = new github version: '3.0.0'
handler.setApiToken ginst, process.env.PROBOT_API_TOKEN
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we launch our hubot from the command line, we will need to use a
command like this as we are testing locally from our laptop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ PROBOT_SECRET=XYZABC \
PROBOT_API_TOKEN=926a701550d4dfae93250dbdc068cce887531 \
HUBOT_SLACK_TOKEN=xoxb-3295776784-nZxl1H3nyLsVcgdD29r1PZCq \
./bin/hubot -a slack</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we publish into Heroku, we will want to set these as environment
variables using the appropriate Heroku commands.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ heroku config:set PROBOT_API_TOKEN=926a701550d4dfae93250dbdc068cce887531
Adding config vars and restarting myapp... done, v12
PROBOT_API_TOKEN=926a701550d4dfae93250dbdc068cce887531

$ heroku config:set PROBOT_SECRET=XYZABC
Adding config vars and restarting myapp... done, v12
PROBOT_SECRET=XYZABC</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget that when we run our tests, we will need to specify the
environment variables on the command line as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ PROBOT_SECRET=XYZABC \
PROBOT_API_TOKEN=926a701550d4dfae93250dbdc068cce887531 \
node_modules/jasmine-node/bin/jasmine-node --coffee \
spec/pr-delegator.spec.coffee</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary">Summary</h3>
<div class="paragraph">
<p>Our Hubot is alive! We went through building a robot which can
interact with us inside a chat room, then refactored the robot so that its
functionality is contained into a highly testable module. Along
the way, we got intimate with the Hubot API, and even discussed how to
modify (and the drawbacks surrounding) modifying the source code to
Hubot itself. Finally we demonstrated how to use the Activities API
receiving (and faking data) coming from a GitHub webhook.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-10-05 15:35:18 PDT
</div>
</div>
</body>
</html>